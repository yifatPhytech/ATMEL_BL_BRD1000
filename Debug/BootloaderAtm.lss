
BootloaderAtm.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000046a  00800100  0000f858  00001e7c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00001858  0000e000  0000e000  00000624  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .blspare      00000550  0000d000  0000d000  000000d4  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .bss          0000097c  0080056a  0080056a  000022e6  2**0
                  ALLOC
  4 .eeprom       00000402  00810000  00810000  000022e6  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  5 .comment      00000030  00000000  00000000  000026e8  2**0
                  CONTENTS, READONLY
  6 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00002718  2**2
                  CONTENTS, READONLY
  7 .debug_aranges 00000338  00000000  00000000  00002758  2**3
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_info   000033d3  00000000  00000000  00002a90  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_abbrev 00001332  00000000  00000000  00005e63  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_line   00001f8d  00000000  00000000  00007195  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_frame  00000c08  00000000  00000000  00009124  2**2
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_str    00000c9d  00000000  00000000  00009d2c  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_loc    0000301c  00000000  00000000  0000a9c9  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_ranges 000002b8  00000000  00000000  0000d9e5  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

0000e000 <__vectors>:
    e000:	0c 94 3e 70 	jmp	0xe07c	; 0xe07c <__ctors_end>
    e004:	0c 94 5b 70 	jmp	0xe0b6	; 0xe0b6 <__bad_interrupt>
    e008:	0c 94 5b 70 	jmp	0xe0b6	; 0xe0b6 <__bad_interrupt>
    e00c:	0c 94 5b 70 	jmp	0xe0b6	; 0xe0b6 <__bad_interrupt>
    e010:	0c 94 5b 70 	jmp	0xe0b6	; 0xe0b6 <__bad_interrupt>
    e014:	0c 94 5b 70 	jmp	0xe0b6	; 0xe0b6 <__bad_interrupt>
    e018:	0c 94 5b 70 	jmp	0xe0b6	; 0xe0b6 <__bad_interrupt>
    e01c:	0c 94 5b 70 	jmp	0xe0b6	; 0xe0b6 <__bad_interrupt>
    e020:	0c 94 40 73 	jmp	0xe680	; 0xe680 <__vector_8>
    e024:	0c 94 5b 70 	jmp	0xe0b6	; 0xe0b6 <__bad_interrupt>
    e028:	0c 94 5b 70 	jmp	0xe0b6	; 0xe0b6 <__bad_interrupt>
    e02c:	0c 94 5b 70 	jmp	0xe0b6	; 0xe0b6 <__bad_interrupt>
    e030:	0c 94 5b 70 	jmp	0xe0b6	; 0xe0b6 <__bad_interrupt>
    e034:	0c 94 1c 73 	jmp	0xe638	; 0xe638 <__vector_13>
    e038:	0c 94 5b 70 	jmp	0xe0b6	; 0xe0b6 <__bad_interrupt>
    e03c:	0c 94 5b 70 	jmp	0xe0b6	; 0xe0b6 <__bad_interrupt>
    e040:	0c 94 5b 70 	jmp	0xe0b6	; 0xe0b6 <__bad_interrupt>
    e044:	0c 94 5b 70 	jmp	0xe0b6	; 0xe0b6 <__bad_interrupt>
    e048:	0c 94 5b 70 	jmp	0xe0b6	; 0xe0b6 <__bad_interrupt>
    e04c:	0c 94 5b 70 	jmp	0xe0b6	; 0xe0b6 <__bad_interrupt>
    e050:	0c 94 5b 70 	jmp	0xe0b6	; 0xe0b6 <__bad_interrupt>
    e054:	0c 94 5b 70 	jmp	0xe0b6	; 0xe0b6 <__bad_interrupt>
    e058:	0c 94 5b 70 	jmp	0xe0b6	; 0xe0b6 <__bad_interrupt>
    e05c:	0c 94 5b 70 	jmp	0xe0b6	; 0xe0b6 <__bad_interrupt>
    e060:	0c 94 5b 70 	jmp	0xe0b6	; 0xe0b6 <__bad_interrupt>
    e064:	0c 94 5b 70 	jmp	0xe0b6	; 0xe0b6 <__bad_interrupt>
    e068:	0c 94 5b 70 	jmp	0xe0b6	; 0xe0b6 <__bad_interrupt>
    e06c:	0c 94 5b 70 	jmp	0xe0b6	; 0xe0b6 <__bad_interrupt>
    e070:	0c 94 5b 70 	jmp	0xe0b6	; 0xe0b6 <__bad_interrupt>
    e074:	0c 94 5b 70 	jmp	0xe0b6	; 0xe0b6 <__bad_interrupt>
    e078:	0c 94 5b 70 	jmp	0xe0b6	; 0xe0b6 <__bad_interrupt>

0000e07c <__ctors_end>:
    e07c:	11 24       	eor	r1, r1
    e07e:	1f be       	out	0x3f, r1	; 63
    e080:	cf ef       	ldi	r28, 0xFF	; 255
    e082:	d0 e1       	ldi	r29, 0x10	; 16
    e084:	de bf       	out	0x3e, r29	; 62
    e086:	cd bf       	out	0x3d, r28	; 61

0000e088 <__do_copy_data>:
    e088:	15 e0       	ldi	r17, 0x05	; 5
    e08a:	a0 e0       	ldi	r26, 0x00	; 0
    e08c:	b1 e0       	ldi	r27, 0x01	; 1
    e08e:	e8 e5       	ldi	r30, 0x58	; 88
    e090:	f8 ef       	ldi	r31, 0xF8	; 248
    e092:	02 c0       	rjmp	.+4      	; 0xe098 <__do_copy_data+0x10>
    e094:	05 90       	lpm	r0, Z+
    e096:	0d 92       	st	X+, r0
    e098:	aa 36       	cpi	r26, 0x6A	; 106
    e09a:	b1 07       	cpc	r27, r17
    e09c:	d9 f7       	brne	.-10     	; 0xe094 <__do_copy_data+0xc>

0000e09e <__do_clear_bss>:
    e09e:	2e e0       	ldi	r18, 0x0E	; 14
    e0a0:	aa e6       	ldi	r26, 0x6A	; 106
    e0a2:	b5 e0       	ldi	r27, 0x05	; 5
    e0a4:	01 c0       	rjmp	.+2      	; 0xe0a8 <.do_clear_bss_start>

0000e0a6 <.do_clear_bss_loop>:
    e0a6:	1d 92       	st	X+, r1

0000e0a8 <.do_clear_bss_start>:
    e0a8:	a6 3e       	cpi	r26, 0xE6	; 230
    e0aa:	b2 07       	cpc	r27, r18
    e0ac:	e1 f7       	brne	.-8      	; 0xe0a6 <.do_clear_bss_loop>
    e0ae:	0e 94 31 74 	call	0xe862	; 0xe862 <main>
    e0b2:	0c 94 2a 7c 	jmp	0xf854	; 0xf854 <_exit>

0000e0b6 <__bad_interrupt>:
    e0b6:	0c 94 00 70 	jmp	0xe000	; 0xe000 <__vectors>

0000e0ba <clock_interrupt_100ms>:

volatile unsigned short ms100;

void clock_interrupt_100ms()
{
    ms100++;
    e0ba:	80 91 6d 05 	lds	r24, 0x056D	; 0x80056d <ms100>
    e0be:	90 91 6e 05 	lds	r25, 0x056E	; 0x80056e <ms100+0x1>
    e0c2:	01 96       	adiw	r24, 0x01	; 1
    e0c4:	90 93 6e 05 	sts	0x056E, r25	; 0x80056e <ms100+0x1>
    e0c8:	80 93 6d 05 	sts	0x056D, r24	; 0x80056d <ms100>
    e0cc:	08 95       	ret

0000e0ce <delay_ms>:
}

void delay_ms(unsigned short msecs)
{
    unsigned short ticks = ms100;
    e0ce:	20 91 6d 05 	lds	r18, 0x056D	; 0x80056d <ms100>
    e0d2:	30 91 6e 05 	lds	r19, 0x056E	; 0x80056e <ms100+0x1>
    msecs /= 100;
    e0d6:	64 e6       	ldi	r22, 0x64	; 100
    e0d8:	70 e0       	ldi	r23, 0x00	; 0
    e0da:	0e 94 a4 7b 	call	0xf748	; 0xf748 <__udivmodhi4>
    
    while ((ms100 - ticks) < msecs)
    e0de:	80 91 6d 05 	lds	r24, 0x056D	; 0x80056d <ms100>
    e0e2:	90 91 6e 05 	lds	r25, 0x056E	; 0x80056e <ms100+0x1>
    e0e6:	82 1b       	sub	r24, r18
    e0e8:	93 0b       	sbc	r25, r19
    e0ea:	86 17       	cp	r24, r22
    e0ec:	97 07       	cpc	r25, r23
    e0ee:	10 f4       	brcc	.+4      	; 0xe0f4 <delay_ms+0x26>
    {
	    WATCHDOG_RESET();
    e0f0:	a8 95       	wdr
    e0f2:	f5 cf       	rjmp	.-22     	; 0xe0de <delay_ms+0x10>
    }
}
    e0f4:	08 95       	ret

0000e0f6 <delay_secs>:

void delay_secs(unsigned short secs)
{
	unsigned short ticks = ms100;
    e0f6:	40 91 6d 05 	lds	r20, 0x056D	; 0x80056d <ms100>
    e0fa:	50 91 6e 05 	lds	r21, 0x056E	; 0x80056e <ms100+0x1>
	secs *= 10;
    e0fe:	2a e0       	ldi	r18, 0x0A	; 10
    e100:	bc 01       	movw	r22, r24
    e102:	26 9f       	mul	r18, r22
    e104:	c0 01       	movw	r24, r0
    e106:	27 9f       	mul	r18, r23
    e108:	90 0d       	add	r25, r0
    e10a:	11 24       	eor	r1, r1
	
	while ((ms100 - ticks) < secs)
    e10c:	20 91 6d 05 	lds	r18, 0x056D	; 0x80056d <ms100>
    e110:	30 91 6e 05 	lds	r19, 0x056E	; 0x80056e <ms100+0x1>
    e114:	24 1b       	sub	r18, r20
    e116:	35 0b       	sbc	r19, r21
    e118:	28 17       	cp	r18, r24
    e11a:	39 07       	cpc	r19, r25
    e11c:	10 f4       	brcc	.+4      	; 0xe122 <delay_secs+0x2c>
	{
		WATCHDOG_RESET();
    e11e:	a8 95       	wdr
    e120:	f5 cf       	rjmp	.-22     	; 0xe10c <delay_secs+0x16>
	}
}
    e122:	08 95       	ret

0000e124 <LoadEEPROMData>:

void logHexByte(byte b)
{
	logTx(hex[(b >> 4) & 0xF]);
	logTx(hex[b & 0xF]);
	logTx(' ');
    e124:	f9 99       	sbic	0x1f, 1	; 31
    e126:	fe cf       	rjmp	.-4      	; 0xe124 <LoadEEPROMData>
    e128:	42 e0       	ldi	r20, 0x02	; 2
    e12a:	50 e0       	ldi	r21, 0x00	; 0
    e12c:	60 e0       	ldi	r22, 0x00	; 0
    e12e:	74 e0       	ldi	r23, 0x04	; 4
    e130:	80 ed       	ldi	r24, 0xD0	; 208
    e132:	95 e0       	ldi	r25, 0x05	; 5
    e134:	0e 94 02 7c 	call	0xf804	; 0xf804 <eeprom_read_block>
    e138:	41 e6       	ldi	r20, 0x61	; 97
    e13a:	50 e0       	ldi	r21, 0x00	; 0
    e13c:	60 e0       	ldi	r22, 0x00	; 0
    e13e:	70 e0       	ldi	r23, 0x00	; 0
    e140:	8f e6       	ldi	r24, 0x6F	; 111
    e142:	95 e0       	ldi	r25, 0x05	; 5
    e144:	0e 94 02 7c 	call	0xf804	; 0xf804 <eeprom_read_block>
    e148:	80 91 7e 05 	lds	r24, 0x057E	; 0x80057e <appEepromData+0xf>
    e14c:	82 30       	cpi	r24, 0x02	; 2
    e14e:	10 f0       	brcs	.+4      	; 0xe154 <LoadEEPROMData+0x30>
    e150:	10 92 7e 05 	sts	0x057E, r1	; 0x80057e <appEepromData+0xf>
    e154:	80 91 6f 05 	lds	r24, 0x056F	; 0x80056f <appEepromData>
    e158:	90 91 70 05 	lds	r25, 0x0570	; 0x800570 <appEepromData+0x1>
    e15c:	a0 91 71 05 	lds	r26, 0x0571	; 0x800571 <appEepromData+0x2>
    e160:	b0 91 72 05 	lds	r27, 0x0572	; 0x800572 <appEepromData+0x3>
    e164:	8f 3f       	cpi	r24, 0xFF	; 255
    e166:	9f 4f       	sbci	r25, 0xFF	; 255
    e168:	af 4f       	sbci	r26, 0xFF	; 255
    e16a:	bf 4f       	sbci	r27, 0xFF	; 255
    e16c:	41 f4       	brne	.+16     	; 0xe17e <LoadEEPROMData+0x5a>
    e16e:	10 92 6f 05 	sts	0x056F, r1	; 0x80056f <appEepromData>
    e172:	10 92 70 05 	sts	0x0570, r1	; 0x800570 <appEepromData+0x1>
    e176:	10 92 71 05 	sts	0x0571, r1	; 0x800571 <appEepromData+0x2>
    e17a:	10 92 72 05 	sts	0x0572, r1	; 0x800572 <appEepromData+0x3>
    e17e:	08 95       	ret

0000e180 <SaveEEPROMData>:
    e180:	f9 99       	sbic	0x1f, 1	; 31
    e182:	fe cf       	rjmp	.-4      	; 0xe180 <SaveEEPROMData>
    e184:	42 e0       	ldi	r20, 0x02	; 2
    e186:	50 e0       	ldi	r21, 0x00	; 0
    e188:	60 e0       	ldi	r22, 0x00	; 0
    e18a:	74 e0       	ldi	r23, 0x04	; 4
    e18c:	80 ed       	ldi	r24, 0xD0	; 208
    e18e:	95 e0       	ldi	r25, 0x05	; 5
    e190:	0c 94 12 7c 	jmp	0xf824	; 0xf824 <eeprom_write_block>

0000e194 <InitProgram>:
    e194:	e1 e6       	ldi	r30, 0x61	; 97
    e196:	f0 e0       	ldi	r31, 0x00	; 0
    e198:	80 e8       	ldi	r24, 0x80	; 128
    e19a:	80 83       	st	Z, r24
    e19c:	10 82       	st	Z, r1
    e19e:	90 ee       	ldi	r25, 0xE0	; 224
    e1a0:	91 b9       	out	0x01, r25	; 1
    e1a2:	12 b8       	out	0x02, r1	; 2
    e1a4:	93 e0       	ldi	r25, 0x03	; 3
    e1a6:	94 b9       	out	0x04, r25	; 4
    e1a8:	15 b8       	out	0x05, r1	; 5
    e1aa:	94 e7       	ldi	r25, 0x74	; 116
    e1ac:	97 b9       	out	0x07, r25	; 7
    e1ae:	98 e8       	ldi	r25, 0x88	; 136
    e1b0:	98 b9       	out	0x08, r25	; 8
    e1b2:	9a e7       	ldi	r25, 0x7A	; 122
    e1b4:	9a b9       	out	0x0a, r25	; 10
    e1b6:	9a eb       	ldi	r25, 0xBA	; 186
    e1b8:	9b b9       	out	0x0b, r25	; 11
    e1ba:	14 bc       	out	0x24, r1	; 36
    e1bc:	15 bc       	out	0x25, r1	; 37
    e1be:	16 bc       	out	0x26, r1	; 38
    e1c0:	17 bc       	out	0x27, r1	; 39
    e1c2:	18 bc       	out	0x28, r1	; 40
    e1c4:	10 92 80 00 	sts	0x0080, r1	; 0x800080 <__DATA_REGION_ORIGIN__+0x20>
    e1c8:	9a e0       	ldi	r25, 0x0A	; 10
    e1ca:	90 93 81 00 	sts	0x0081, r25	; 0x800081 <__DATA_REGION_ORIGIN__+0x21>
    e1ce:	9c e4       	ldi	r25, 0x4C	; 76
    e1d0:	90 93 85 00 	sts	0x0085, r25	; 0x800085 <__DATA_REGION_ORIGIN__+0x25>
    e1d4:	10 92 84 00 	sts	0x0084, r1	; 0x800084 <__DATA_REGION_ORIGIN__+0x24>
    e1d8:	10 92 87 00 	sts	0x0087, r1	; 0x800087 <__DATA_REGION_ORIGIN__+0x27>
    e1dc:	10 92 86 00 	sts	0x0086, r1	; 0x800086 <__DATA_REGION_ORIGIN__+0x26>
    e1e0:	93 eb       	ldi	r25, 0xB3	; 179
    e1e2:	90 93 89 00 	sts	0x0089, r25	; 0x800089 <__DATA_REGION_ORIGIN__+0x29>
    e1e6:	9f ef       	ldi	r25, 0xFF	; 255
    e1e8:	90 93 88 00 	sts	0x0088, r25	; 0x800088 <__DATA_REGION_ORIGIN__+0x28>
    e1ec:	10 92 8b 00 	sts	0x008B, r1	; 0x80008b <__DATA_REGION_ORIGIN__+0x2b>
    e1f0:	10 92 8a 00 	sts	0x008A, r1	; 0x80008a <__DATA_REGION_ORIGIN__+0x2a>
    e1f4:	10 92 b6 00 	sts	0x00B6, r1	; 0x8000b6 <__DATA_REGION_ORIGIN__+0x56>
    e1f8:	10 92 b0 00 	sts	0x00B0, r1	; 0x8000b0 <__DATA_REGION_ORIGIN__+0x50>
    e1fc:	10 92 b1 00 	sts	0x00B1, r1	; 0x8000b1 <__DATA_REGION_ORIGIN__+0x51>
    e200:	10 92 b2 00 	sts	0x00B2, r1	; 0x8000b2 <__DATA_REGION_ORIGIN__+0x52>
    e204:	10 92 b3 00 	sts	0x00B3, r1	; 0x8000b3 <__DATA_REGION_ORIGIN__+0x53>
    e208:	10 92 b4 00 	sts	0x00B4, r1	; 0x8000b4 <__DATA_REGION_ORIGIN__+0x54>
    e20c:	10 92 6e 00 	sts	0x006E, r1	; 0x80006e <__DATA_REGION_ORIGIN__+0xe>
    e210:	92 e0       	ldi	r25, 0x02	; 2
    e212:	90 93 6f 00 	sts	0x006F, r25	; 0x80006f <__DATA_REGION_ORIGIN__+0xf>
    e216:	10 92 70 00 	sts	0x0070, r1	; 0x800070 <__DATA_REGION_ORIGIN__+0x10>
    e21a:	80 bf       	out	0x30, r24	; 48
    e21c:	10 92 7b 00 	sts	0x007B, r1	; 0x80007b <__DATA_REGION_ORIGIN__+0x1b>
    e220:	10 92 7f 00 	sts	0x007F, r1	; 0x80007f <__DATA_REGION_ORIGIN__+0x1f>
    e224:	08 95       	ret

0000e226 <InitPeripherals>:
    e226:	10 92 c0 00 	sts	0x00C0, r1	; 0x8000c0 <__DATA_REGION_ORIGIN__+0x60>
    e22a:	10 92 c1 00 	sts	0x00C1, r1	; 0x8000c1 <__DATA_REGION_ORIGIN__+0x61>
    e22e:	96 e0       	ldi	r25, 0x06	; 6
    e230:	90 93 c2 00 	sts	0x00C2, r25	; 0x8000c2 <__DATA_REGION_ORIGIN__+0x62>
    e234:	10 92 c5 00 	sts	0x00C5, r1	; 0x8000c5 <__DATA_REGION_ORIGIN__+0x65>
    e238:	8b e0       	ldi	r24, 0x0B	; 11
    e23a:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__DATA_REGION_ORIGIN__+0x64>
    e23e:	22 e0       	ldi	r18, 0x02	; 2
    e240:	20 93 c8 00 	sts	0x00C8, r18	; 0x8000c8 <__DATA_REGION_ORIGIN__+0x68>
    e244:	10 92 c9 00 	sts	0x00C9, r1	; 0x8000c9 <__DATA_REGION_ORIGIN__+0x69>
    e248:	90 93 ca 00 	sts	0x00CA, r25	; 0x8000ca <__DATA_REGION_ORIGIN__+0x6a>
    e24c:	10 92 cd 00 	sts	0x00CD, r1	; 0x8000cd <__DATA_REGION_ORIGIN__+0x6d>
    e250:	80 93 cc 00 	sts	0x00CC, r24	; 0x8000cc <__DATA_REGION_ORIGIN__+0x6c>
    e254:	8d ef       	ldi	r24, 0xFD	; 253
    e256:	80 93 7e 00 	sts	0x007E, r24	; 0x80007e <__DATA_REGION_ORIGIN__+0x1e>
    e25a:	80 ec       	ldi	r24, 0xC0	; 192
    e25c:	80 93 7c 00 	sts	0x007C, r24	; 0x80007c <__DATA_REGION_ORIGIN__+0x1c>
    e260:	87 e0       	ldi	r24, 0x07	; 7
    e262:	80 93 7a 00 	sts	0x007A, r24	; 0x80007a <__DATA_REGION_ORIGIN__+0x1a>
    e266:	10 92 7b 00 	sts	0x007B, r1	; 0x80007b <__DATA_REGION_ORIGIN__+0x1b>
    e26a:	1c bc       	out	0x2c, r1	; 44
    e26c:	10 92 bc 00 	sts	0x00BC, r1	; 0x8000bc <__DATA_REGION_ORIGIN__+0x5c>
    e270:	10 92 69 00 	sts	0x0069, r1	; 0x800069 <__DATA_REGION_ORIGIN__+0x9>
    e274:	1d ba       	out	0x1d, r1	; 29
    e276:	10 92 68 00 	sts	0x0068, r1	; 0x800068 <__DATA_REGION_ORIGIN__+0x8>
    e27a:	08 95       	ret

0000e27c <qscanf>:
    e27c:	cf 92       	push	r12
    e27e:	df 92       	push	r13
    e280:	ef 92       	push	r14
    e282:	ff 92       	push	r15
    e284:	1f 93       	push	r17
    e286:	cf 93       	push	r28
    e288:	df 93       	push	r29
    e28a:	cd b7       	in	r28, 0x3d	; 61
    e28c:	de b7       	in	r29, 0x3e	; 62
    e28e:	ca 84       	ldd	r12, Y+10	; 0x0a
    e290:	db 84       	ldd	r13, Y+11	; 0x0b
    e292:	2c 85       	ldd	r18, Y+12	; 0x0c
    e294:	3d 85       	ldd	r19, Y+13	; 0x0d
    e296:	d9 01       	movw	r26, r18
    e298:	8c 91       	ld	r24, X
    e29a:	8e 35       	cpi	r24, 0x5E	; 94
    e29c:	11 f4       	brne	.+4      	; 0xe2a2 <qscanf+0x26>
    e29e:	2f 5f       	subi	r18, 0xFF	; 255
    e2a0:	3f 4f       	sbci	r19, 0xFF	; 255
    e2a2:	fe 01       	movw	r30, r28
    e2a4:	3e 96       	adiw	r30, 0x0e	; 14
    e2a6:	80 e0       	ldi	r24, 0x00	; 0
    e2a8:	1a e0       	ldi	r17, 0x0A	; 10
    e2aa:	d9 01       	movw	r26, r18
    e2ac:	9c 91       	ld	r25, X
    e2ae:	99 23       	and	r25, r25
    e2b0:	09 f4       	brne	.+2      	; 0xe2b4 <qscanf+0x38>
    e2b2:	7a c0       	rjmp	.+244    	; 0xe3a8 <qscanf+0x12c>
    e2b4:	95 32       	cpi	r25, 0x25	; 37
    e2b6:	09 f0       	breq	.+2      	; 0xe2ba <qscanf+0x3e>
    e2b8:	6b c0       	rjmp	.+214    	; 0xe390 <qscanf+0x114>
    e2ba:	a9 01       	movw	r20, r18
    e2bc:	4e 5f       	subi	r20, 0xFE	; 254
    e2be:	5f 4f       	sbci	r21, 0xFF	; 255
    e2c0:	d9 01       	movw	r26, r18
    e2c2:	11 96       	adiw	r26, 0x01	; 1
    e2c4:	9c 91       	ld	r25, X
    e2c6:	95 36       	cpi	r25, 0x65	; 101
    e2c8:	29 f1       	breq	.+74     	; 0xe314 <qscanf+0x98>
    e2ca:	28 f4       	brcc	.+10     	; 0xe2d6 <qscanf+0x5a>
    e2cc:	92 36       	cpi	r25, 0x62	; 98
    e2ce:	99 f0       	breq	.+38     	; 0xe2f6 <qscanf+0x7a>
    e2d0:	94 36       	cpi	r25, 0x64	; 100
    e2d2:	89 f0       	breq	.+34     	; 0xe2f6 <qscanf+0x7a>
    e2d4:	67 c0       	rjmp	.+206    	; 0xe3a4 <qscanf+0x128>
    e2d6:	90 37       	cpi	r25, 0x70	; 112
    e2d8:	91 f0       	breq	.+36     	; 0xe2fe <qscanf+0x82>
    e2da:	93 37       	cpi	r25, 0x73	; 115
    e2dc:	09 f0       	breq	.+2      	; 0xe2e0 <qscanf+0x64>
    e2de:	62 c0       	rjmp	.+196    	; 0xe3a4 <qscanf+0x128>
    e2e0:	bf 01       	movw	r22, r30
    e2e2:	6e 5f       	subi	r22, 0xFE	; 254
    e2e4:	7f 4f       	sbci	r23, 0xFF	; 255
    e2e6:	01 90       	ld	r0, Z+
    e2e8:	f0 81       	ld	r31, Z
    e2ea:	e0 2d       	mov	r30, r0
    e2ec:	d9 01       	movw	r26, r18
    e2ee:	12 96       	adiw	r26, 0x02	; 2
    e2f0:	fc 90       	ld	r15, X
    e2f2:	96 01       	movw	r18, r12
    e2f4:	41 c0       	rjmp	.+130    	; 0xe378 <qscanf+0xfc>
    e2f6:	76 01       	movw	r14, r12
    e2f8:	60 e0       	ldi	r22, 0x00	; 0
    e2fa:	70 e0       	ldi	r23, 0x00	; 0
    e2fc:	0d c0       	rjmp	.+26     	; 0xe318 <qscanf+0x9c>
    e2fe:	9f 01       	movw	r18, r30
    e300:	2e 5f       	subi	r18, 0xFE	; 254
    e302:	3f 4f       	sbci	r19, 0xFF	; 255
    e304:	01 90       	ld	r0, Z+
    e306:	f0 81       	ld	r31, Z
    e308:	e0 2d       	mov	r30, r0
    e30a:	30 97       	sbiw	r30, 0x00	; 0
    e30c:	61 f1       	breq	.+88     	; 0xe366 <qscanf+0xea>
    e30e:	d1 82       	std	Z+1, r13	; 0x01
    e310:	c0 82       	st	Z, r12
    e312:	29 c0       	rjmp	.+82     	; 0xe366 <qscanf+0xea>
    e314:	9f 01       	movw	r18, r30
    e316:	27 c0       	rjmp	.+78     	; 0xe366 <qscanf+0xea>
    e318:	67 01       	movw	r12, r14
    e31a:	d7 01       	movw	r26, r14
    e31c:	3c 91       	ld	r19, X
    e31e:	bf ef       	ldi	r27, 0xFF	; 255
    e320:	eb 1a       	sub	r14, r27
    e322:	fb 0a       	sbc	r15, r27
    e324:	20 ed       	ldi	r18, 0xD0	; 208
    e326:	23 0f       	add	r18, r19
    e328:	2a 30       	cpi	r18, 0x0A	; 10
    e32a:	68 f4       	brcc	.+26     	; 0xe346 <qscanf+0xca>
    e32c:	16 9f       	mul	r17, r22
    e32e:	d0 01       	movw	r26, r0
    e330:	17 9f       	mul	r17, r23
    e332:	b0 0d       	add	r27, r0
    e334:	11 24       	eor	r1, r1
    e336:	23 2f       	mov	r18, r19
    e338:	30 e0       	ldi	r19, 0x00	; 0
    e33a:	20 53       	subi	r18, 0x30	; 48
    e33c:	31 09       	sbc	r19, r1
    e33e:	b9 01       	movw	r22, r18
    e340:	6a 0f       	add	r22, r26
    e342:	7b 1f       	adc	r23, r27
    e344:	e9 cf       	rjmp	.-46     	; 0xe318 <qscanf+0x9c>
    e346:	9f 01       	movw	r18, r30
    e348:	2e 5f       	subi	r18, 0xFE	; 254
    e34a:	3f 4f       	sbci	r19, 0xFF	; 255
    e34c:	01 90       	ld	r0, Z+
    e34e:	f0 81       	ld	r31, Z
    e350:	e0 2d       	mov	r30, r0
    e352:	92 36       	cpi	r25, 0x62	; 98
    e354:	21 f4       	brne	.+8      	; 0xe35e <qscanf+0xe2>
    e356:	30 97       	sbiw	r30, 0x00	; 0
    e358:	31 f0       	breq	.+12     	; 0xe366 <qscanf+0xea>
    e35a:	60 83       	st	Z, r22
    e35c:	04 c0       	rjmp	.+8      	; 0xe366 <qscanf+0xea>
    e35e:	30 97       	sbiw	r30, 0x00	; 0
    e360:	11 f0       	breq	.+4      	; 0xe366 <qscanf+0xea>
    e362:	71 83       	std	Z+1, r23	; 0x01
    e364:	60 83       	st	Z, r22
    e366:	8f 5f       	subi	r24, 0xFF	; 255
    e368:	f9 01       	movw	r30, r18
    e36a:	1c c0       	rjmp	.+56     	; 0xe3a4 <qscanf+0x128>
    e36c:	99 23       	and	r25, r25
    e36e:	51 f0       	breq	.+20     	; 0xe384 <qscanf+0x108>
    e370:	30 97       	sbiw	r30, 0x00	; 0
    e372:	11 f0       	breq	.+4      	; 0xe378 <qscanf+0xfc>
    e374:	90 83       	st	Z, r25
    e376:	31 96       	adiw	r30, 0x01	; 1
    e378:	69 01       	movw	r12, r18
    e37a:	d9 01       	movw	r26, r18
    e37c:	9d 91       	ld	r25, X+
    e37e:	9d 01       	movw	r18, r26
    e380:	f9 12       	cpse	r15, r25
    e382:	f4 cf       	rjmp	.-24     	; 0xe36c <qscanf+0xf0>
    e384:	30 97       	sbiw	r30, 0x00	; 0
    e386:	09 f0       	breq	.+2      	; 0xe38a <qscanf+0x10e>
    e388:	10 82       	st	Z, r1
    e38a:	8f 5f       	subi	r24, 0xFF	; 255
    e38c:	fb 01       	movw	r30, r22
    e38e:	0a c0       	rjmp	.+20     	; 0xe3a4 <qscanf+0x128>
    e390:	d6 01       	movw	r26, r12
    e392:	4c 91       	ld	r20, X
    e394:	94 13       	cpse	r25, r20
    e396:	08 c0       	rjmp	.+16     	; 0xe3a8 <qscanf+0x12c>
    e398:	a9 01       	movw	r20, r18
    e39a:	4f 5f       	subi	r20, 0xFF	; 255
    e39c:	5f 4f       	sbci	r21, 0xFF	; 255
    e39e:	bf ef       	ldi	r27, 0xFF	; 255
    e3a0:	cb 1a       	sub	r12, r27
    e3a2:	db 0a       	sbc	r13, r27
    e3a4:	9a 01       	movw	r18, r20
    e3a6:	81 cf       	rjmp	.-254    	; 0xe2aa <qscanf+0x2e>
    e3a8:	90 e0       	ldi	r25, 0x00	; 0
    e3aa:	df 91       	pop	r29
    e3ac:	cf 91       	pop	r28
    e3ae:	1f 91       	pop	r17
    e3b0:	ff 90       	pop	r15
    e3b2:	ef 90       	pop	r14
    e3b4:	df 90       	pop	r13
    e3b6:	cf 90       	pop	r12
    e3b8:	08 95       	ret

0000e3ba <qprintfv>:
    e3ba:	7f 92       	push	r7
    e3bc:	8f 92       	push	r8
    e3be:	9f 92       	push	r9
    e3c0:	af 92       	push	r10
    e3c2:	bf 92       	push	r11
    e3c4:	cf 92       	push	r12
    e3c6:	df 92       	push	r13
    e3c8:	ef 92       	push	r14
    e3ca:	ff 92       	push	r15
    e3cc:	0f 93       	push	r16
    e3ce:	1f 93       	push	r17
    e3d0:	cf 93       	push	r28
    e3d2:	df 93       	push	r29
    e3d4:	ec 01       	movw	r28, r24
    e3d6:	fa 01       	movw	r30, r20
    e3d8:	8a e0       	ldi	r24, 0x0A	; 10
    e3da:	88 2e       	mov	r8, r24
    e3dc:	91 2c       	mov	r9, r1
    e3de:	a1 2c       	mov	r10, r1
    e3e0:	b1 2c       	mov	r11, r1
    e3e2:	db 01       	movw	r26, r22
    e3e4:	8c 91       	ld	r24, X
    e3e6:	88 23       	and	r24, r24
    e3e8:	09 f4       	brne	.+2      	; 0xe3ec <qprintfv+0x32>
    e3ea:	7a c0       	rjmp	.+244    	; 0xe4e0 <qprintfv+0x126>
    e3ec:	6b 01       	movw	r12, r22
    e3ee:	85 32       	cpi	r24, 0x25	; 37
    e3f0:	09 f0       	breq	.+2      	; 0xe3f4 <qprintfv+0x3a>
    e3f2:	6b c0       	rjmp	.+214    	; 0xe4ca <qprintfv+0x110>
    e3f4:	82 e0       	ldi	r24, 0x02	; 2
    e3f6:	c8 0e       	add	r12, r24
    e3f8:	d1 1c       	adc	r13, r1
    e3fa:	db 01       	movw	r26, r22
    e3fc:	11 96       	adiw	r26, 0x01	; 1
    e3fe:	8c 91       	ld	r24, X
    e400:	84 36       	cpi	r24, 0x64	; 100
    e402:	e1 f0       	breq	.+56     	; 0xe43c <qprintfv+0x82>
    e404:	38 f4       	brcc	.+14     	; 0xe414 <qprintfv+0x5a>
    e406:	83 32       	cpi	r24, 0x23	; 35
    e408:	09 f4       	brne	.+2      	; 0xe40c <qprintfv+0x52>
    e40a:	4b c0       	rjmp	.+150    	; 0xe4a2 <qprintfv+0xe8>
    e40c:	82 36       	cpi	r24, 0x62	; 98
    e40e:	09 f0       	breq	.+2      	; 0xe412 <qprintfv+0x58>
    e410:	63 c0       	rjmp	.+198    	; 0xe4d8 <qprintfv+0x11e>
    e412:	14 c0       	rjmp	.+40     	; 0xe43c <qprintfv+0x82>
    e414:	8c 36       	cpi	r24, 0x6C	; 108
    e416:	51 f0       	breq	.+20     	; 0xe42c <qprintfv+0x72>
    e418:	83 37       	cpi	r24, 0x73	; 115
    e41a:	09 f0       	breq	.+2      	; 0xe41e <qprintfv+0x64>
    e41c:	5d c0       	rjmp	.+186    	; 0xe4d8 <qprintfv+0x11e>
    e41e:	8f 01       	movw	r16, r30
    e420:	0e 5f       	subi	r16, 0xFE	; 254
    e422:	1f 4f       	sbci	r17, 0xFF	; 255
    e424:	a0 81       	ld	r26, Z
    e426:	b1 81       	ldd	r27, Z+1	; 0x01
    e428:	fe 01       	movw	r30, r28
    e42a:	35 c0       	rjmp	.+106    	; 0xe496 <qprintfv+0xdc>
    e42c:	8f 01       	movw	r16, r30
    e42e:	0c 5f       	subi	r16, 0xFC	; 252
    e430:	1f 4f       	sbci	r17, 0xFF	; 255
    e432:	20 81       	ld	r18, Z
    e434:	31 81       	ldd	r19, Z+1	; 0x01
    e436:	42 81       	ldd	r20, Z+2	; 0x02
    e438:	53 81       	ldd	r21, Z+3	; 0x03
    e43a:	07 c0       	rjmp	.+14     	; 0xe44a <qprintfv+0x90>
    e43c:	8f 01       	movw	r16, r30
    e43e:	0e 5f       	subi	r16, 0xFE	; 254
    e440:	1f 4f       	sbci	r17, 0xFF	; 255
    e442:	20 81       	ld	r18, Z
    e444:	31 81       	ldd	r19, Z+1	; 0x01
    e446:	40 e0       	ldi	r20, 0x00	; 0
    e448:	50 e0       	ldi	r21, 0x00	; 0
    e44a:	7c 2e       	mov	r7, r28
    e44c:	ec 2e       	mov	r14, r28
    e44e:	fd 2e       	mov	r15, r29
    e450:	ca 01       	movw	r24, r20
    e452:	b9 01       	movw	r22, r18
    e454:	a5 01       	movw	r20, r10
    e456:	94 01       	movw	r18, r8
    e458:	0e 94 b8 7b 	call	0xf770	; 0xf770 <__udivmodsi4>
    e45c:	60 5d       	subi	r22, 0xD0	; 208
    e45e:	d7 01       	movw	r26, r14
    e460:	6d 93       	st	X+, r22
    e462:	7d 01       	movw	r14, r26
    e464:	9a 2f       	mov	r25, r26
    e466:	97 19       	sub	r25, r7
    e468:	21 15       	cp	r18, r1
    e46a:	31 05       	cpc	r19, r1
    e46c:	41 05       	cpc	r20, r1
    e46e:	51 05       	cpc	r21, r1
    e470:	79 f7       	brne	.-34     	; 0xe450 <qprintfv+0x96>
    e472:	89 2f       	mov	r24, r25
    e474:	de 01       	movw	r26, r28
    e476:	82 30       	cpi	r24, 0x02	; 2
    e478:	58 f0       	brcs	.+22     	; 0xe490 <qprintfv+0xd6>
    e47a:	2c 91       	ld	r18, X
    e47c:	e8 2f       	mov	r30, r24
    e47e:	f0 e0       	ldi	r31, 0x00	; 0
    e480:	31 97       	sbiw	r30, 0x01	; 1
    e482:	ea 0f       	add	r30, r26
    e484:	fb 1f       	adc	r31, r27
    e486:	30 81       	ld	r19, Z
    e488:	3d 93       	st	X+, r19
    e48a:	20 83       	st	Z, r18
    e48c:	82 50       	subi	r24, 0x02	; 2
    e48e:	f3 cf       	rjmp	.-26     	; 0xe476 <qprintfv+0xbc>
    e490:	c9 0f       	add	r28, r25
    e492:	d1 1d       	adc	r29, r1
    e494:	22 c0       	rjmp	.+68     	; 0xe4da <qprintfv+0x120>
    e496:	ef 01       	movw	r28, r30
    e498:	8d 91       	ld	r24, X+
    e49a:	88 23       	and	r24, r24
    e49c:	f1 f0       	breq	.+60     	; 0xe4da <qprintfv+0x120>
    e49e:	81 93       	st	Z+, r24
    e4a0:	fa cf       	rjmp	.-12     	; 0xe496 <qprintfv+0xdc>
    e4a2:	8f 01       	movw	r16, r30
    e4a4:	0c 5f       	subi	r16, 0xFC	; 252
    e4a6:	1f 4f       	sbci	r17, 0xFF	; 255
    e4a8:	20 81       	ld	r18, Z
    e4aa:	31 81       	ldd	r19, Z+1	; 0x01
    e4ac:	de 01       	movw	r26, r28
    e4ae:	82 81       	ldd	r24, Z+2	; 0x02
    e4b0:	ed 01       	movw	r28, r26
    e4b2:	f9 01       	movw	r30, r18
    e4b4:	91 91       	ld	r25, Z+
    e4b6:	9f 01       	movw	r18, r30
    e4b8:	99 23       	and	r25, r25
    e4ba:	79 f0       	breq	.+30     	; 0xe4da <qprintfv+0x120>
    e4bc:	88 23       	and	r24, r24
    e4be:	69 f0       	breq	.+26     	; 0xe4da <qprintfv+0x120>
    e4c0:	81 50       	subi	r24, 0x01	; 1
    e4c2:	93 32       	cpi	r25, 0x23	; 35
    e4c4:	51 f0       	breq	.+20     	; 0xe4da <qprintfv+0x120>
    e4c6:	9d 93       	st	X+, r25
    e4c8:	f3 cf       	rjmp	.-26     	; 0xe4b0 <qprintfv+0xf6>
    e4ca:	9f ef       	ldi	r25, 0xFF	; 255
    e4cc:	c9 1a       	sub	r12, r25
    e4ce:	d9 0a       	sbc	r13, r25
    e4d0:	88 83       	st	Y, r24
    e4d2:	8f 01       	movw	r16, r30
    e4d4:	21 96       	adiw	r28, 0x01	; 1
    e4d6:	01 c0       	rjmp	.+2      	; 0xe4da <qprintfv+0x120>
    e4d8:	8f 01       	movw	r16, r30
    e4da:	f8 01       	movw	r30, r16
    e4dc:	b6 01       	movw	r22, r12
    e4de:	81 cf       	rjmp	.-254    	; 0xe3e2 <qprintfv+0x28>
    e4e0:	18 82       	st	Y, r1
    e4e2:	ce 01       	movw	r24, r28
    e4e4:	df 91       	pop	r29
    e4e6:	cf 91       	pop	r28
    e4e8:	1f 91       	pop	r17
    e4ea:	0f 91       	pop	r16
    e4ec:	ff 90       	pop	r15
    e4ee:	ef 90       	pop	r14
    e4f0:	df 90       	pop	r13
    e4f2:	cf 90       	pop	r12
    e4f4:	bf 90       	pop	r11
    e4f6:	af 90       	pop	r10
    e4f8:	9f 90       	pop	r9
    e4fa:	8f 90       	pop	r8
    e4fc:	7f 90       	pop	r7
    e4fe:	08 95       	ret

0000e500 <qprintf>:
    e500:	cf 93       	push	r28
    e502:	df 93       	push	r29
    e504:	cd b7       	in	r28, 0x3d	; 61
    e506:	de b7       	in	r29, 0x3e	; 62
    e508:	ae 01       	movw	r20, r28
    e50a:	47 5f       	subi	r20, 0xF7	; 247
    e50c:	5f 4f       	sbci	r21, 0xFF	; 255
    e50e:	6f 81       	ldd	r22, Y+7	; 0x07
    e510:	78 85       	ldd	r23, Y+8	; 0x08
    e512:	8d 81       	ldd	r24, Y+5	; 0x05
    e514:	9e 81       	ldd	r25, Y+6	; 0x06
    e516:	0e 94 dd 71 	call	0xe3ba	; 0xe3ba <qprintfv>
    e51a:	df 91       	pop	r29
    e51c:	cf 91       	pop	r28
    e51e:	08 95       	ret

0000e520 <logTx>:
    e520:	90 91 c8 00 	lds	r25, 0x00C8	; 0x8000c8 <__DATA_REGION_ORIGIN__+0x68>
    e524:	95 ff       	sbrs	r25, 5
    e526:	fc cf       	rjmp	.-8      	; 0xe520 <logTx>
    e528:	80 93 ce 00 	sts	0x00CE, r24	; 0x8000ce <__DATA_REGION_ORIGIN__+0x6e>
    e52c:	08 95       	ret

0000e52e <logStrRaw>:
}

void logStrRaw(const char* str)
{
    e52e:	fc 01       	movw	r30, r24
	while (*str)
    e530:	91 91       	ld	r25, Z+
    e532:	99 23       	and	r25, r25
    e534:	41 f0       	breq	.+16     	; 0xe546 <logStrRaw+0x18>
	{
		WATCHDOG_RESET();
    e536:	a8 95       	wdr

		while ((UCSR1A & DATA_REGISTER_EMPTY)==0);
    e538:	80 91 c8 00 	lds	r24, 0x00C8	; 0x8000c8 <__DATA_REGION_ORIGIN__+0x68>
    e53c:	85 ff       	sbrs	r24, 5
    e53e:	fc cf       	rjmp	.-8      	; 0xe538 <logStrRaw+0xa>
		UDR1 = *str++;
    e540:	90 93 ce 00 	sts	0x00CE, r25	; 0x8000ce <__DATA_REGION_ORIGIN__+0x6e>
    e544:	f5 cf       	rjmp	.-22     	; 0xe530 <logStrRaw+0x2>
		//while(( UCSR1A & (1<<TXC1))==0);
	}
};
    e546:	08 95       	ret

0000e548 <logStr>:

void logStr(const char* str)
{
	logStrRaw(str);
    e548:	0e 94 97 72 	call	0xe52e	; 0xe52e <logStrRaw>
	logStrRaw("\r\n");
    e54c:	8f ef       	ldi	r24, 0xFF	; 255
    e54e:	94 e0       	ldi	r25, 0x04	; 4
    e550:	0c 94 97 72 	jmp	0xe52e	; 0xe52e <logStrRaw>

0000e554 <logd>:
};

void logd(const char* fmt, ...)
{
    e554:	cf 93       	push	r28
    e556:	df 93       	push	r29
    e558:	cd b7       	in	r28, 0x3d	; 61
    e55a:	de b7       	in	r29, 0x3e	; 62
    e55c:	ae 01       	movw	r20, r28
    e55e:	4b 5f       	subi	r20, 0xFB	; 251
    e560:	5f 4f       	sbci	r21, 0xFF	; 255
    e562:	fa 01       	movw	r30, r20
    e564:	61 91       	ld	r22, Z+
    e566:	71 91       	ld	r23, Z+
    e568:	af 01       	movw	r20, r30
	va_list args;

	va_start(args, fmt);
	qprintfv(debugbuf, fmt, args);
    e56a:	82 ed       	ldi	r24, 0xD2	; 210
    e56c:	95 e0       	ldi	r25, 0x05	; 5
    e56e:	0e 94 dd 71 	call	0xe3ba	; 0xe3ba <qprintfv>
	va_end(args);

	logStrRaw(debugbuf);
    e572:	82 ed       	ldi	r24, 0xD2	; 210
    e574:	95 e0       	ldi	r25, 0x05	; 5
    e576:	0e 94 97 72 	call	0xe52e	; 0xe52e <logStrRaw>
	logStrRaw("\r\n");
    e57a:	8f ef       	ldi	r24, 0xFF	; 255
    e57c:	94 e0       	ldi	r25, 0x04	; 4
    e57e:	0e 94 97 72 	call	0xe52e	; 0xe52e <logStrRaw>
}
    e582:	df 91       	pop	r29
    e584:	cf 91       	pop	r28
    e586:	08 95       	ret

0000e588 <PowerDown>:
	_logd("End wakeup: MCUSR %d", MCUSR);
}

#ifdef SleepMode
void PowerDown(bool eternally)
{
    e588:	cf 93       	push	r28
    e58a:	c8 2f       	mov	r28, r24
    _logs(eternally ? "PowerDown Forever" : "PowerDown");
    e58c:	81 11       	cpse	r24, r1
    e58e:	03 c0       	rjmp	.+6      	; 0xe596 <PowerDown+0xe>
    e590:	8a e3       	ldi	r24, 0x3A	; 58
    e592:	91 e0       	ldi	r25, 0x01	; 1
    e594:	02 c0       	rjmp	.+4      	; 0xe59a <PowerDown+0x12>
    e596:	88 e2       	ldi	r24, 0x28	; 40
    e598:	91 e0       	ldi	r25, 0x01	; 1
    e59a:	0e 94 a4 72 	call	0xe548	; 0xe548 <logStr>
	delay_ms(100);
    e59e:	84 e6       	ldi	r24, 0x64	; 100
    e5a0:	90 e0       	ldi	r25, 0x00	; 0
    e5a2:	0e 94 67 70 	call	0xe0ce	; 0xe0ce <delay_ms>

    bExtReset = FALSE;
    e5a6:	10 92 49 06 	sts	0x0649, r1	; 0x800649 <bExtReset>
	
    // Port A initialization
    // Function: Bit7=Out Bit6=Out Bit5=Out Bit4=In Bit3=In Bit2=In Bit1=In Bit0=In
    DDRA=(1<<DDA7) | (1<<DDA6) | (1<<DDA5) | (0<<DDA4) | (0<<DDA3) | (0<<DDA2) | (0<<DDA1) | (0<<DDA0);
    e5aa:	80 ee       	ldi	r24, 0xE0	; 224
    e5ac:	81 b9       	out	0x01, r24	; 1
    // State: Bit7=0 Bit6=0 Bit5=0 Bit4=T Bit3=T Bit2=T Bit1=T Bit0=T
    PORTA=(0<<PORTA7) | (0<<PORTA6) | (0<<PORTA5) | (0<<PORTA4) | (0<<PORTA3) | (0<<PORTA2) | (0<<PORTA1) | (0<<PORTA0);
    e5ae:	12 b8       	out	0x02, r1	; 2

    // Port B initialization
    // Function: Bit7=Out Bit6=Out Bit5=Out Bit4=In Bit3=In Bit2=In Bit1=Out Bit0=In
    DDRB = ((0<<DDB7) | (0<<DDB6) | (0<<DDB5) | (0<<DDB4) | (0<<DDB3) | (0<<DDB2) |(1<<DDB1)  | (1<<DDB0));
    e5b0:	83 e0       	ldi	r24, 0x03	; 3
    e5b2:	84 b9       	out	0x04, r24	; 4
    // State: Bit7=0 Bit6=0 Bit5=0 Bit4=P Bit3=T Bit2=T Bit1=0 Bit0=T
    PORTB = ((0<<PORTB7) | (0<<PORTB6) | (0<<PORTB5) | (0<<PORTB4) | (0<<PORTB3)  | (0<<PORTB2) | (0<<PORTB1) | (0<<PORTB0));
    e5b4:	15 b8       	out	0x05, r1	; 5
	
    // Port C initialization
    // Function: Bit7=Out Bit6=Out Bit5=Out Bit4=Out Bit3=Out Bit2=Out Bit1=Out Bit0=Out
    DDRC=(0<<DDC7) | (1<<DDC6) | (1<<DDC5) | (1<<DDC4) | (0<<DDC3) | (1<<DDC2) | (1<<DDC1) | (1<<DDC0);
    e5b6:	97 e7       	ldi	r25, 0x77	; 119
    e5b8:	97 b9       	out	0x07, r25	; 7
    // State: Bit7=0 Bit6=0 Bit5=0 Bit4=0 Bit3=0 Bit2=0 Bit1=1 Bit0=1
    PORTC=(0<<PORTC7) | (0<<PORTC6) | (0<<PORTC5) | (0<<PORTC4) | (0<<PORTC3) | (0<<PORTC2) | (1<<PORTC1) | (1<<PORTC0);
    e5ba:	88 b9       	out	0x08, r24	; 8
	
    // Port D initialization
    // Function: Bit7=In Bit6=Out Bit5=Out Bit4=Out Bit3=In Bit2=In Bit1=Out Bit0=In
    DDRD=(0<<DDD7) | (1<<DDD6) | (1<<DDD5) | (1<<DDD4) | (1<<DDD3) | (0<<DDD2) | (1<<DDD1) | (0<<DDD0);
    e5bc:	8a e7       	ldi	r24, 0x7A	; 122
    e5be:	8a b9       	out	0x0a, r24	; 10
    // State: Bit7=0 Bit6=0 Bit5=0 Bit4=0 Bit3=0 Bit2=T Bit1=0 Bit0=T
    PORTD=(0<<PORTD7) | (0<<PORTD6) | (1<<PORTD5) | (0<<PORTD4) | (0<<PORTD3) | (0<<PORTD2) | (0<<PORTD1) | (0<<PORTD0);
    e5c0:	80 e2       	ldi	r24, 0x20	; 32
    e5c2:	8b b9       	out	0x0b, r24	; 11
	
    DISABLE_UART1();
    e5c4:	10 92 c9 00 	sts	0x00C9, r1	; 0x8000c9 <__DATA_REGION_ORIGIN__+0x69>
    DISABLE_TIMER1_COMPA();
    e5c8:	80 91 6f 00 	lds	r24, 0x006F	; 0x80006f <__DATA_REGION_ORIGIN__+0xf>
    e5cc:	8d 7f       	andi	r24, 0xFD	; 253
    e5ce:	80 93 6f 00 	sts	0x006F, r24	; 0x80006f <__DATA_REGION_ORIGIN__+0xf>
	if (!eternally)
	{
		// Watchdog Timer initialization
		// Watchdog Timer Prescaler: OSC/1024k
		// Watchdog timeout action: Interrupt
		MCUSR |= (1<<WDRF);
    e5d2:	84 b7       	in	r24, 0x34	; 52
    PORTD=(0<<PORTD7) | (0<<PORTD6) | (1<<PORTD5) | (0<<PORTD4) | (0<<PORTD3) | (0<<PORTD2) | (0<<PORTD1) | (0<<PORTD0);
	
    DISABLE_UART1();
    DISABLE_TIMER1_COMPA();

	if (!eternally)
    e5d4:	c1 11       	cpse	r28, r1
    e5d6:	0c c0       	rjmp	.+24     	; 0xe5f0 <PowerDown+0x68>
	{
		// Watchdog Timer initialization
		// Watchdog Timer Prescaler: OSC/1024k
		// Watchdog timeout action: Interrupt
		MCUSR |= (1<<WDRF);
    e5d8:	88 60       	ori	r24, 0x08	; 8
    e5da:	84 bf       	out	0x34, r24	; 52
		WATCHDOG_RESET();
    e5dc:	a8 95       	wdr
		WDTCSR |= (1 << WDCE) | (1<<WDE);
    e5de:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
    e5e2:	88 61       	ori	r24, 0x18	; 24
    e5e4:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
		WDTCSR = (1 << WDIF) | (1 << WDIE) | (1 << WDP3) | (0 << WDCE) | (0 << WDE) | (0 << WDP2) | (0 << WDP1) | (1 << WDP0);
    e5e8:	81 ee       	ldi	r24, 0xE1	; 225
    e5ea:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
    e5ee:	09 c0       	rjmp	.+18     	; 0xe602 <PowerDown+0x7a>
	}
	else
	{
		/* Clear WDRF in MCUSR */
		MCUSR &= ~(1<<WDRF);
    e5f0:	87 7f       	andi	r24, 0xF7	; 247
    e5f2:	84 bf       	out	0x34, r24	; 52
		/* Write logical one to WDCE and WDE */
		/* Keep old prescaler setting to prevent unintentional time-out */
		WDTCSR |= (1<<WDCE) | (1<<WDE);
    e5f4:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
    e5f8:	88 61       	ori	r24, 0x18	; 24
    e5fa:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
		/* Turn off WDT */
		WDTCSR = 0x00;
    e5fe:	10 92 60 00 	sts	0x0060, r1	; 0x800060 <__DATA_REGION_ORIGIN__>

	}

	// wait for very long timeout
	for (wdtSecs = 0; wdtSecs < SEC_UPGRADE_CYCLE; )
    e602:	10 92 44 06 	sts	0x0644, r1	; 0x800644 <wdtSecs+0x1>
    e606:	10 92 43 06 	sts	0x0643, r1	; 0x800643 <wdtSecs>
    e60a:	80 91 43 06 	lds	r24, 0x0643	; 0x800643 <wdtSecs>
    e60e:	90 91 44 06 	lds	r25, 0x0644	; 0x800644 <wdtSecs+0x1>
    e612:	40 97       	sbiw	r24, 0x10	; 16
    e614:	48 f4       	brcc	.+18     	; 0xe628 <PowerDown+0xa0>
		//else
		//{
		//	PORTA |= (1<<PORTA7) | (1<<PORTA6) | (1<<PORTA5);
		//}

		SMCR |= 4;
    e616:	83 b7       	in	r24, 0x33	; 51
    e618:	84 60       	ori	r24, 0x04	; 4
    e61a:	83 bf       	out	0x33, r24	; 51
		SMCR |= 1;
    e61c:	83 b7       	in	r24, 0x33	; 51
    e61e:	81 60       	ori	r24, 0x01	; 1
    e620:	83 bf       	out	0x33, r24	; 51

		asm volatile("sleep");
    e622:	88 95       	sleep
		asm volatile("nop;nop;"); 		//wakeup from sleep mode
    e624:	00 00       	nop
    e626:	f1 cf       	rjmp	.-30     	; 0xe60a <PowerDown+0x82>
	}

	WakeUpProcedure(false);
    e628:	80 e0       	ldi	r24, 0x00	; 0
    e62a:	0e 94 00 68 	call	0xd000	; 0xd000 <WakeUpProcedure>

	_logs("PowerDown end");
    e62e:	84 e4       	ldi	r24, 0x44	; 68
    e630:	91 e0       	ldi	r25, 0x01	; 1
}
    e632:	cf 91       	pop	r28
		asm volatile("nop;nop;"); 		//wakeup from sleep mode
	}

	WakeUpProcedure(false);

	_logs("PowerDown end");
    e634:	0c 94 a4 72 	jmp	0xe548	; 0xe548 <logStr>

0000e638 <__vector_13>:

extern unsigned int wdtSecs;

// Timer1 output compare A interrupt service routine - EVERY 100 ML SECOND
ISR(TIMER1_COMPA_vect)
{
    e638:	1f 92       	push	r1
    e63a:	0f 92       	push	r0
    e63c:	0f b6       	in	r0, 0x3f	; 63
    e63e:	0f 92       	push	r0
    e640:	11 24       	eor	r1, r1
    e642:	2f 93       	push	r18
    e644:	3f 93       	push	r19
    e646:	4f 93       	push	r20
    e648:	5f 93       	push	r21
    e64a:	6f 93       	push	r22
    e64c:	7f 93       	push	r23
    e64e:	8f 93       	push	r24
    e650:	9f 93       	push	r25
    e652:	af 93       	push	r26
    e654:	bf 93       	push	r27
    e656:	ef 93       	push	r30
    e658:	ff 93       	push	r31
    clock_interrupt_100ms();
    e65a:	0e 94 5d 70 	call	0xe0ba	; 0xe0ba <clock_interrupt_100ms>
}
    e65e:	ff 91       	pop	r31
    e660:	ef 91       	pop	r30
    e662:	bf 91       	pop	r27
    e664:	af 91       	pop	r26
    e666:	9f 91       	pop	r25
    e668:	8f 91       	pop	r24
    e66a:	7f 91       	pop	r23
    e66c:	6f 91       	pop	r22
    e66e:	5f 91       	pop	r21
    e670:	4f 91       	pop	r20
    e672:	3f 91       	pop	r19
    e674:	2f 91       	pop	r18
    e676:	0f 90       	pop	r0
    e678:	0f be       	out	0x3f, r0	; 63
    e67a:	0f 90       	pop	r0
    e67c:	1f 90       	pop	r1
    e67e:	18 95       	reti

0000e680 <__vector_8>:

// Watchdog timer to wakeup bootloader every 8secs
ISR(WDT_vect)
{
    e680:	1f 92       	push	r1
    e682:	0f 92       	push	r0
    e684:	0f b6       	in	r0, 0x3f	; 63
    e686:	0f 92       	push	r0
    e688:	11 24       	eor	r1, r1
    e68a:	8f 93       	push	r24
    e68c:	9f 93       	push	r25
	wdtSecs += 8;
    e68e:	80 91 43 06 	lds	r24, 0x0643	; 0x800643 <wdtSecs>
    e692:	90 91 44 06 	lds	r25, 0x0644	; 0x800644 <wdtSecs+0x1>
    e696:	08 96       	adiw	r24, 0x08	; 8
    e698:	90 93 44 06 	sts	0x0644, r25	; 0x800644 <wdtSecs+0x1>
    e69c:	80 93 43 06 	sts	0x0643, r24	; 0x800643 <wdtSecs>
}
    e6a0:	9f 91       	pop	r25
    e6a2:	8f 91       	pop	r24
    e6a4:	0f 90       	pop	r0
    e6a6:	0f be       	out	0x3f, r0	; 63
    e6a8:	0f 90       	pop	r0
    e6aa:	1f 90       	pop	r1
    e6ac:	18 95       	reti

0000e6ae <jump_to_app>:
	return result;
}

static void jump_to_app()
{
	DISABLE_INTERRUPTS();
    e6ae:	f8 94       	cli

	// switch vectors to application
	MCUCR = (1 << IVCE);
    e6b0:	81 e0       	ldi	r24, 0x01	; 1
    e6b2:	85 bf       	out	0x35, r24	; 53
	MCUCR = (0 << IVSEL);
    e6b4:	15 be       	out	0x35, r1	; 53

	// reconfigure and reset watchdog
	WATCHDOG_RESET();
    e6b6:	a8 95       	wdr
	WATCHDOG_ENABLE_STEP1();
    e6b8:	e0 e6       	ldi	r30, 0x60	; 96
    e6ba:	f0 e0       	ldi	r31, 0x00	; 0
    e6bc:	89 e3       	ldi	r24, 0x39	; 57
    e6be:	80 83       	st	Z, r24
	WATCHDOG_ENABLE_STEP2();
    e6c0:	89 e2       	ldi	r24, 0x29	; 41
    e6c2:	80 83       	st	Z, r24

	// stop timer
	DISABLE_TIMER1();
    e6c4:	10 92 81 00 	sts	0x0081, r1	; 0x800081 <__DATA_REGION_ORIGIN__+0x21>
	DISABLE_TIMER1_COMPA();
    e6c8:	af e6       	ldi	r26, 0x6F	; 111
    e6ca:	b0 e0       	ldi	r27, 0x00	; 0
    e6cc:	8c 91       	ld	r24, X
    e6ce:	8d 7f       	andi	r24, 0xFD	; 253
    e6d0:	8c 93       	st	X, r24

	_logd("Jump to app, MCUSR: %d, WDTCSR: %d, MCUCR: %d", MCUSR, WDTCSR, MCUCR);
    e6d2:	25 b7       	in	r18, 0x35	; 53
    e6d4:	90 81       	ld	r25, Z
    e6d6:	84 b7       	in	r24, 0x34	; 52
    e6d8:	1f 92       	push	r1
    e6da:	2f 93       	push	r18
    e6dc:	1f 92       	push	r1
    e6de:	9f 93       	push	r25
    e6e0:	1f 92       	push	r1
    e6e2:	8f 93       	push	r24
    e6e4:	83 e6       	ldi	r24, 0x63	; 99
    e6e6:	91 e0       	ldi	r25, 0x01	; 1
    e6e8:	9f 93       	push	r25
    e6ea:	8f 93       	push	r24
    e6ec:	0e 94 aa 72 	call	0xe554	; 0xe554 <logd>

	WATCHDOG_RESET();
    e6f0:	a8 95       	wdr
	jump_to_app_reset_vector();
    e6f2:	8d b7       	in	r24, 0x3d	; 61
    e6f4:	9e b7       	in	r25, 0x3e	; 62
    e6f6:	08 96       	adiw	r24, 0x08	; 8
    e6f8:	0f b6       	in	r0, 0x3f	; 63
    e6fa:	f8 94       	cli
    e6fc:	9e bf       	out	0x3e, r25	; 62
    e6fe:	0f be       	out	0x3f, r0	; 63
    e700:	8d bf       	out	0x3d, r24	; 61
    e702:	e0 e0       	ldi	r30, 0x00	; 0
    e704:	f0 e0       	ldi	r31, 0x00	; 0
    e706:	09 94       	ijmp

0000e708 <getVersion>:
bool isAppValid;
unsigned short crc;
byte upgradeRetries;
bool shortModemInit = true;

const char* getVersion() { return VERSION; }
    e708:	81 e9       	ldi	r24, 0x91	; 145
    e70a:	91 e0       	ldi	r25, 0x01	; 1
    e70c:	08 95       	ret

0000e70e <CRC16_CCITT>:
void InitPeripherals();
void PowerDown(bool eternally);

// calculates CRC code of the specified buffer
unsigned short CRC16_CCITT(const byte __flash * data, unsigned short length, unsigned short crc)
{
    e70e:	68 0f       	add	r22, r24
    e710:	79 1f       	adc	r23, r25
	byte b;

	while (length > 0)
    e712:	86 17       	cp	r24, r22
    e714:	97 07       	cpc	r25, r23
    e716:	09 f1       	breq	.+66     	; 0xe75a <CRC16_CCITT+0x4c>
	{
		b = pgm_read_byte(data);
    e718:	fc 01       	movw	r30, r24
    e71a:	24 91       	lpm	r18, Z
		crc = (crc >> 8) | (crc << 8);
    e71c:	54 27       	eor	r21, r20
    e71e:	45 27       	eor	r20, r21
    e720:	54 27       	eor	r21, r20
		crc ^= b;
    e722:	42 27       	eor	r20, r18
		crc ^= (crc & 0xff) >> 4;
    e724:	9a 01       	movw	r18, r20
    e726:	33 27       	eor	r19, r19
    e728:	e4 e0       	ldi	r30, 0x04	; 4
    e72a:	36 95       	lsr	r19
    e72c:	27 95       	ror	r18
    e72e:	ea 95       	dec	r30
    e730:	e1 f7       	brne	.-8      	; 0xe72a <CRC16_CCITT+0x1c>
    e732:	42 27       	eor	r20, r18
    e734:	53 27       	eor	r21, r19
		crc ^= crc << 12;
    e736:	9a 01       	movw	r18, r20
    e738:	32 2f       	mov	r19, r18
    e73a:	22 27       	eor	r18, r18
    e73c:	32 95       	swap	r19
    e73e:	30 7f       	andi	r19, 0xF0	; 240
    e740:	42 27       	eor	r20, r18
    e742:	53 27       	eor	r21, r19
		crc ^= (crc & 0xff) << 5;
    e744:	9a 01       	movw	r18, r20
    e746:	33 27       	eor	r19, r19
    e748:	a5 e0       	ldi	r26, 0x05	; 5
    e74a:	22 0f       	add	r18, r18
    e74c:	33 1f       	adc	r19, r19
    e74e:	aa 95       	dec	r26
    e750:	e1 f7       	brne	.-8      	; 0xe74a <CRC16_CCITT+0x3c>
    e752:	42 27       	eor	r20, r18
    e754:	53 27       	eor	r21, r19

		++data;
    e756:	01 96       	adiw	r24, 0x01	; 1
    e758:	dc cf       	rjmp	.-72     	; 0xe712 <CRC16_CCITT+0x4>
		--length;
	}
	
	return crc;
}
    e75a:	ca 01       	movw	r24, r20
    e75c:	08 95       	ret

0000e75e <checkAppHeader>:

void checkAppHeader()
{
	isAppValid = false;
    e75e:	10 92 36 06 	sts	0x0636, r1	; 0x800636 <isAppValid>
	
	// read app header
	memcpy_P(&appHeader, (const void*)BL_APP_HEADER_ADDRESS, sizeof(appHeader));
    e762:	46 e0       	ldi	r20, 0x06	; 6
    e764:	50 e0       	ldi	r21, 0x00	; 0
    e766:	60 e0       	ldi	r22, 0x00	; 0
    e768:	7f ec       	ldi	r23, 0xCF	; 207
    e76a:	88 e3       	ldi	r24, 0x38	; 56
    e76c:	96 e0       	ldi	r25, 0x06	; 6
    e76e:	0e 94 e9 7b 	call	0xf7d2	; 0xf7d2 <memcpy_P>

	// calculate crc
	crc = CRC16_CCITT((const BYTE __flash*)BL_APP_START_ADDRESS, BL_APP_HEADER_ADDRESS, 0xFFFF);
    e772:	4f ef       	ldi	r20, 0xFF	; 255
    e774:	5f ef       	ldi	r21, 0xFF	; 255
    e776:	60 e0       	ldi	r22, 0x00	; 0
    e778:	7f ec       	ldi	r23, 0xCF	; 207
    e77a:	80 e0       	ldi	r24, 0x00	; 0
    e77c:	90 e0       	ldi	r25, 0x00	; 0
    e77e:	0e 94 87 73 	call	0xe70e	; 0xe70e <CRC16_CCITT>
    e782:	80 93 41 06 	sts	0x0641, r24	; 0x800641 <crc>
    e786:	90 93 42 06 	sts	0x0642, r25	; 0x800642 <crc+0x1>
	
	_logd("APP v: %d, crc: %d, acrc: %d", appHeader._version, appHeader._crc, crc);
    e78a:	9f 93       	push	r25
    e78c:	8f 93       	push	r24
    e78e:	80 91 3b 06 	lds	r24, 0x063B	; 0x80063b <appHeader+0x3>
    e792:	8f 93       	push	r24
    e794:	80 91 3a 06 	lds	r24, 0x063A	; 0x80063a <appHeader+0x2>
    e798:	8f 93       	push	r24
    e79a:	80 91 3d 06 	lds	r24, 0x063D	; 0x80063d <appHeader+0x5>
    e79e:	8f 93       	push	r24
    e7a0:	80 91 3c 06 	lds	r24, 0x063C	; 0x80063c <appHeader+0x4>
    e7a4:	8f 93       	push	r24
    e7a6:	85 e9       	ldi	r24, 0x95	; 149
    e7a8:	91 e0       	ldi	r25, 0x01	; 1
    e7aa:	9f 93       	push	r25
    e7ac:	8f 93       	push	r24
    e7ae:	0e 94 aa 72 	call	0xe554	; 0xe554 <logd>

	if (appHeader._magic != BL_APP_HEADER_MAGIC)
    e7b2:	8d b7       	in	r24, 0x3d	; 61
    e7b4:	9e b7       	in	r25, 0x3e	; 62
    e7b6:	08 96       	adiw	r24, 0x08	; 8
    e7b8:	0f b6       	in	r0, 0x3f	; 63
    e7ba:	f8 94       	cli
    e7bc:	9e bf       	out	0x3e, r25	; 62
    e7be:	0f be       	out	0x3f, r0	; 63
    e7c0:	8d bf       	out	0x3d, r24	; 61
    e7c2:	80 91 38 06 	lds	r24, 0x0638	; 0x800638 <appHeader>
    e7c6:	90 91 39 06 	lds	r25, 0x0639	; 0x800639 <appHeader+0x1>
    e7ca:	8d 34       	cpi	r24, 0x4D	; 77
    e7cc:	9e 44       	sbci	r25, 0x4E	; 78
    e7ce:	71 f4       	brne	.+28     	; 0xe7ec <checkAppHeader+0x8e>
	{
		return;
	}
	
	if (appHeader._crc != crc)
    e7d0:	20 91 3a 06 	lds	r18, 0x063A	; 0x80063a <appHeader+0x2>
    e7d4:	30 91 3b 06 	lds	r19, 0x063B	; 0x80063b <appHeader+0x3>
    e7d8:	80 91 41 06 	lds	r24, 0x0641	; 0x800641 <crc>
    e7dc:	90 91 42 06 	lds	r25, 0x0642	; 0x800642 <crc+0x1>
    e7e0:	28 17       	cp	r18, r24
    e7e2:	39 07       	cpc	r19, r25
    e7e4:	19 f4       	brne	.+6      	; 0xe7ec <checkAppHeader+0x8e>
	{
		return;
	}
	
	isAppValid = true;
    e7e6:	81 e0       	ldi	r24, 0x01	; 1
    e7e8:	80 93 36 06 	sts	0x0636, r24	; 0x800636 <isAppValid>
    e7ec:	08 95       	ret

0000e7ee <doAppUpgrade>:
}

bool doAppUpgrade()
{
    e7ee:	cf 93       	push	r28
	bool result = false;
	bool bModemOn = false;

	_logs("Start SW Update");
    e7f0:	82 eb       	ldi	r24, 0xB2	; 178
    e7f2:	91 e0       	ldi	r25, 0x01	; 1
    e7f4:	0e 94 a4 72 	call	0xe548	; 0xe548 <logStr>

	// switch on modem
	if (turnModemOn(false))
    e7f8:	80 e0       	ldi	r24, 0x00	; 0
    e7fa:	0e 94 4c 68 	call	0xd098	; 0xd098 <turnModemOn>
    e7fe:	81 11       	cpse	r24, r1
    e800:	02 c0       	rjmp	.+4      	; 0xe806 <doAppUpgrade+0x18>
	isAppValid = true;
}

bool doAppUpgrade()
{
	bool result = false;
    e802:	c0 e0       	ldi	r28, 0x00	; 0
    e804:	29 c0       	rjmp	.+82     	; 0xe858 <doAppUpgrade+0x6a>
	_logs("Start SW Update");

	// switch on modem
	if (turnModemOn(false))
	{
		if (shortModemInit)
    e806:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__data_start>
    e80a:	88 23       	and	r24, r24
    e80c:	31 f0       	breq	.+12     	; 0xe81a <doAppUpgrade+0x2c>
			bModemOn = initModem();
		// initialize modem
		if (bModemOn)
		{
			// connect modem
			if (connectModem(true))
    e80e:	81 e0       	ldi	r24, 0x01	; 1
    e810:	0e 94 f9 7a 	call	0xf5f2	; 0xf5f2 <connectModem>
    e814:	88 23       	and	r24, r24
    e816:	a9 f3       	breq	.-22     	; 0xe802 <doAppUpgrade+0x14>
    e818:	05 c0       	rjmp	.+10     	; 0xe824 <doAppUpgrade+0x36>
	if (turnModemOn(false))
	{
		if (shortModemInit)
			bModemOn = true;
		else
			bModemOn = initModem();
    e81a:	0e 94 5c 79 	call	0xf2b8	; 0xf2b8 <initModem>
		// initialize modem
		if (bModemOn)
    e81e:	88 23       	and	r24, r24
    e820:	81 f3       	breq	.-32     	; 0xe802 <doAppUpgrade+0x14>
    e822:	f5 cf       	rjmp	.-22     	; 0xe80e <doAppUpgrade+0x20>
		{
			// connect modem
			if (connectModem(true))
			{
				// update server that we are downloading
				if (updateFirmwareStatus(FW_STATUS_UPDATING))
    e824:	83 e0       	ldi	r24, 0x03	; 3
    e826:	0e 94 51 6a 	call	0xd4a2	; 0xd4a2 <updateFirmwareStatus>
    e82a:	88 23       	and	r24, r24
    e82c:	51 f3       	breq	.-44     	; 0xe802 <doAppUpgrade+0x14>
				{
					// now we can download file
					if (downloadFirmware(blEepromData.versionUpdate))
    e82e:	80 91 d0 05 	lds	r24, 0x05D0	; 0x8005d0 <blEepromData>
    e832:	90 91 d1 05 	lds	r25, 0x05D1	; 0x8005d1 <blEepromData+0x1>
    e836:	0e 94 89 69 	call	0xd312	; 0xd312 <downloadFirmware>
    e83a:	88 23       	and	r24, r24
    e83c:	39 f0       	breq	.+14     	; 0xe84c <doAppUpgrade+0x5e>
					{
						// check new firmware for validity
						checkAppHeader();
    e83e:	0e 94 af 73 	call	0xe75e	; 0xe75e <checkAppHeader>

						result = isAppValid;
    e842:	c0 91 36 06 	lds	r28, 0x0636	; 0x800636 <isAppValid>
					}
				
					// update server with final status
					updateFirmwareStatus(result ? FW_STATUS_READY : FW_STATUS_FAILURE);
    e846:	c1 11       	cpse	r28, r1
    e848:	04 c0       	rjmp	.+8      	; 0xe852 <doAppUpgrade+0x64>
    e84a:	01 c0       	rjmp	.+2      	; 0xe84e <doAppUpgrade+0x60>
	isAppValid = true;
}

bool doAppUpgrade()
{
	bool result = false;
    e84c:	c0 e0       	ldi	r28, 0x00	; 0

						result = isAppValid;
					}
				
					// update server with final status
					updateFirmwareStatus(result ? FW_STATUS_READY : FW_STATUS_FAILURE);
    e84e:	84 e0       	ldi	r24, 0x04	; 4
    e850:	01 c0       	rjmp	.+2      	; 0xe854 <doAppUpgrade+0x66>
    e852:	81 e0       	ldi	r24, 0x01	; 1
    e854:	0e 94 51 6a 	call	0xd4a2	; 0xd4a2 <updateFirmwareStatus>
			}
		}
	}

	// close modem and leave
	closeModem();
    e858:	0e 94 24 7b 	call	0xf648	; 0xf648 <closeModem>

	return result;
}
    e85c:	8c 2f       	mov	r24, r28
    e85e:	cf 91       	pop	r28
    e860:	08 95       	ret

0000e862 <main>:
};

int main(void)
{
	// switch interrupt vectors to bootloader
	DISABLE_INTERRUPTS();
    e862:	f8 94       	cli
	MCUCR = (1 << IVCE);
    e864:	c1 e0       	ldi	r28, 0x01	; 1
    e866:	c5 bf       	out	0x35, r28	; 53
	MCUCR = (1 << IVSEL);
    e868:	82 e0       	ldi	r24, 0x02	; 2
    e86a:	85 bf       	out	0x35, r24	; 53
	ENABLE_INTERRUPTS();
    e86c:	78 94       	sei

	// initial reset
	WATCHDOG_RESET();
    e86e:	a8 95       	wdr

	// initialize all IO's and vars
	WakeUpProcedure(true);
    e870:	81 e0       	ldi	r24, 0x01	; 1
    e872:	0e 94 00 68 	call	0xd000	; 0xd000 <WakeUpProcedure>
	LoadEEPROMData();
    e876:	0e 94 92 70 	call	0xe124	; 0xe124 <LoadEEPROMData>

    WATCHDOG_ENABLE_STEP1();
    e87a:	89 e3       	ldi	r24, 0x39	; 57
    e87c:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
    WATCHDOG_ENABLE_STEP2();
    e880:	89 e2       	ldi	r24, 0x29	; 41
    e882:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>

	// remember reset reason
	if (MCUSR & ((1<<EXTRF) | (1<<PORF)))
    e886:	84 b7       	in	r24, 0x34	; 52
    e888:	83 70       	andi	r24, 0x03	; 3
    e88a:	11 f0       	breq	.+4      	; 0xe890 <main+0x2e>
	{
		bExtReset = TRUE;
    e88c:	c0 93 49 06 	sts	0x0649, r28	; 0x800649 <bExtReset>
	}

	_logd("BL v%s rr: %d, pu: %d, id: %l", VERSION, MCUSR, blEepromData.versionUpdate, appEepromData.eLoggerID);
    e890:	84 b7       	in	r24, 0x34	; 52
    e892:	90 91 72 05 	lds	r25, 0x0572	; 0x800572 <appEepromData+0x3>
    e896:	9f 93       	push	r25
    e898:	90 91 71 05 	lds	r25, 0x0571	; 0x800571 <appEepromData+0x2>
    e89c:	9f 93       	push	r25
    e89e:	90 91 70 05 	lds	r25, 0x0570	; 0x800570 <appEepromData+0x1>
    e8a2:	9f 93       	push	r25
    e8a4:	90 91 6f 05 	lds	r25, 0x056F	; 0x80056f <appEepromData>
    e8a8:	9f 93       	push	r25
    e8aa:	90 91 d1 05 	lds	r25, 0x05D1	; 0x8005d1 <blEepromData+0x1>
    e8ae:	9f 93       	push	r25
    e8b0:	90 91 d0 05 	lds	r25, 0x05D0	; 0x8005d0 <blEepromData>
    e8b4:	9f 93       	push	r25
    e8b6:	1f 92       	push	r1
    e8b8:	8f 93       	push	r24
    e8ba:	81 e9       	ldi	r24, 0x91	; 145
    e8bc:	91 e0       	ldi	r25, 0x01	; 1
    e8be:	9f 93       	push	r25
    e8c0:	8f 93       	push	r24
    e8c2:	82 ec       	ldi	r24, 0xC2	; 194
    e8c4:	91 e0       	ldi	r25, 0x01	; 1
    e8c6:	9f 93       	push	r25
    e8c8:	8f 93       	push	r24
    e8ca:	0e 94 aa 72 	call	0xe554	; 0xe554 <logd>

	// check whether we need an upgrade to perform
	performUpgrade = blEepromData.versionUpdate != 0xFFFF && blEepromData.versionUpdate > 0;
    e8ce:	80 91 d0 05 	lds	r24, 0x05D0	; 0x8005d0 <blEepromData>
    e8d2:	90 91 d1 05 	lds	r25, 0x05D1	; 0x8005d1 <blEepromData+0x1>
    e8d6:	01 97       	sbiw	r24, 0x01	; 1
    e8d8:	21 e0       	ldi	r18, 0x01	; 1
    e8da:	4d b7       	in	r20, 0x3d	; 61
    e8dc:	5e b7       	in	r21, 0x3e	; 62
    e8de:	44 5f       	subi	r20, 0xF4	; 244
    e8e0:	5f 4f       	sbci	r21, 0xFF	; 255
    e8e2:	0f b6       	in	r0, 0x3f	; 63
    e8e4:	f8 94       	cli
    e8e6:	5e bf       	out	0x3e, r21	; 62
    e8e8:	0f be       	out	0x3f, r0	; 63
    e8ea:	4d bf       	out	0x3d, r20	; 61
    e8ec:	8e 3f       	cpi	r24, 0xFE	; 254
    e8ee:	9f 4f       	sbci	r25, 0xFF	; 255
    e8f0:	08 f0       	brcs	.+2      	; 0xe8f4 <main+0x92>
    e8f2:	20 e0       	ldi	r18, 0x00	; 0
    e8f4:	20 93 37 06 	sts	0x0637, r18	; 0x800637 <performUpgrade>
	upgradeRetries = 0;
    e8f8:	10 92 4a 06 	sts	0x064A, r1	; 0x80064a <upgradeRetries>
	shortModemInit = isModemOn();
    e8fc:	0e 94 d9 76 	call	0xedb2	; 0xedb2 <isModemOn>
    e900:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__data_start>
	
	if (shortModemInit)
    e904:	88 23       	and	r24, r24
    e906:	21 f0       	breq	.+8      	; 0xe910 <main+0xae>
	{
		_logs("SHORT INIT");
    e908:	80 ee       	ldi	r24, 0xE0	; 224
    e90a:	91 e0       	ldi	r25, 0x01	; 1
    e90c:	0e 94 a4 72 	call	0xe548	; 0xe548 <logStr>
	}

	// check application CRC and information structure
	checkAppHeader();
    e910:	0e 94 af 73 	call	0xe75e	; 0xe75e <checkAppHeader>
	
	// no upgrade required and application is valid, jump to it
	if (!performUpgrade && isAppValid)
    e914:	80 91 37 06 	lds	r24, 0x0637	; 0x800637 <performUpgrade>
    e918:	81 11       	cpse	r24, r1
    e91a:	05 c0       	rjmp	.+10     	; 0xe926 <main+0xc4>
    e91c:	80 91 36 06 	lds	r24, 0x0636	; 0x800636 <isAppValid>
    e920:	81 11       	cpse	r24, r1
	{
		jump_to_app();
    e922:	0e 94 57 73 	call	0xe6ae	; 0xe6ae <jump_to_app>
	}
	
	// if application is invalid but no upgrade is requested, we have to perform upgrade in any way
	if (!isAppValid && !performUpgrade)
    e926:	80 91 36 06 	lds	r24, 0x0636	; 0x800636 <isAppValid>
    e92a:	81 11       	cpse	r24, r1
    e92c:	0b c0       	rjmp	.+22     	; 0xe944 <main+0xe2>
    e92e:	80 91 37 06 	lds	r24, 0x0637	; 0x800637 <performUpgrade>
    e932:	81 11       	cpse	r24, r1
    e934:	07 c0       	rjmp	.+14     	; 0xe944 <main+0xe2>
	{
		performUpgrade = true;
    e936:	81 e0       	ldi	r24, 0x01	; 1
    e938:	80 93 37 06 	sts	0x0637, r24	; 0x800637 <performUpgrade>
		// zero version should mean the latest firmware version for this logger
		blEepromData.versionUpdate = 0;
    e93c:	10 92 d1 05 	sts	0x05D1, r1	; 0x8005d1 <blEepromData+0x1>
    e940:	10 92 d0 05 	sts	0x05D0, r1	; 0x8005d0 <blEepromData>
				jump_to_app();
			}
			else
			{
				#ifdef SleepMode
				_logd("Upgrade retry %d failed.", upgradeRetries);
    e944:	cb ee       	ldi	r28, 0xEB	; 235
    e946:	d1 e0       	ldi	r29, 0x01	; 1
		WATCHDOG_RESET();
		cliTask();

		#ifndef Cli
		// perform upgrade if specified so
		if (performUpgrade)
    e948:	80 91 37 06 	lds	r24, 0x0637	; 0x800637 <performUpgrade>
	}
	
	// this is command line API of boot loader
	while (1)
	{
		WATCHDOG_RESET();
    e94c:	a8 95       	wdr
		cliTask();

		#ifndef Cli
		// perform upgrade if specified so
		if (performUpgrade)
    e94e:	88 23       	and	r24, r24
    e950:	e9 f3       	breq	.-6      	; 0xe94c <main+0xea>
		{
			// sleep eternally when battery is empty
			if (btrStatus != BTR_FULL)
    e952:	80 91 3e 06 	lds	r24, 0x063E	; 0x80063e <btrStatus>
    e956:	88 23       	and	r24, r24
    e958:	71 f0       	breq	.+28     	; 0xe976 <main+0x114>
			{
				#ifdef SleepMode
				closeModem();
    e95a:	0e 94 24 7b 	call	0xf648	; 0xf648 <closeModem>
				checkAppHeader();
    e95e:	0e 94 af 73 	call	0xe75e	; 0xe75e <checkAppHeader>
				if (isAppValid)
    e962:	80 91 36 06 	lds	r24, 0x0636	; 0x800636 <isAppValid>
    e966:	88 23       	and	r24, r24
    e968:	19 f0       	breq	.+6      	; 0xe970 <main+0x10e>
				{
					jump_to_app();
    e96a:	0e 94 57 73 	call	0xe6ae	; 0xe6ae <jump_to_app>
    e96e:	03 c0       	rjmp	.+6      	; 0xe976 <main+0x114>
				}
				else
				{
					PowerDown(true);
    e970:	81 e0       	ldi	r24, 0x01	; 1
    e972:	0e 94 c4 72 	call	0xe588	; 0xe588 <PowerDown>
				}
				#endif
			}

			if (doAppUpgrade())
    e976:	0e 94 f7 73 	call	0xe7ee	; 0xe7ee <doAppUpgrade>
    e97a:	88 23       	and	r24, r24
    e97c:	59 f0       	breq	.+22     	; 0xe994 <main+0x132>
			{
				performUpgrade = false;
    e97e:	10 92 37 06 	sts	0x0637, r1	; 0x800637 <performUpgrade>

				// mark that we do not need to upgrade any more
				blEepromData.versionUpdate = 0;
    e982:	10 92 d1 05 	sts	0x05D1, r1	; 0x8005d1 <blEepromData+0x1>
    e986:	10 92 d0 05 	sts	0x05D0, r1	; 0x8005d0 <blEepromData>
				SaveEEPROMData();
    e98a:	0e 94 c0 70 	call	0xe180	; 0xe180 <SaveEEPROMData>

				// now call application
				jump_to_app();
    e98e:	0e 94 57 73 	call	0xe6ae	; 0xe6ae <jump_to_app>
    e992:	da cf       	rjmp	.-76     	; 0xe948 <main+0xe6>
			}
			else
			{
				#ifdef SleepMode
				_logd("Upgrade retry %d failed.", upgradeRetries);
    e994:	80 91 4a 06 	lds	r24, 0x064A	; 0x80064a <upgradeRetries>
    e998:	1f 92       	push	r1
    e99a:	8f 93       	push	r24
    e99c:	df 93       	push	r29
    e99e:	cf 93       	push	r28
    e9a0:	0e 94 aa 72 	call	0xe554	; 0xe554 <logd>

				if (shortModemInit)
    e9a4:	0f 90       	pop	r0
    e9a6:	0f 90       	pop	r0
    e9a8:	0f 90       	pop	r0
    e9aa:	0f 90       	pop	r0
    e9ac:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__data_start>
    e9b0:	88 23       	and	r24, r24
    e9b2:	29 f0       	breq	.+10     	; 0xe9be <main+0x15c>
				{
					closeModem();
    e9b4:	0e 94 24 7b 	call	0xf648	; 0xf648 <closeModem>
					shortModemInit = false;
    e9b8:	10 92 00 01 	sts	0x0100, r1	; 0x800100 <__data_start>
    e9bc:	c5 cf       	rjmp	.-118    	; 0xe948 <main+0xe6>
				}
				else
				{
					upgradeRetries++;
    e9be:	80 91 4a 06 	lds	r24, 0x064A	; 0x80064a <upgradeRetries>
    e9c2:	8f 5f       	subi	r24, 0xFF	; 255
    e9c4:	80 93 4a 06 	sts	0x064A, r24	; 0x80064a <upgradeRetries>

					if (upgradeRetries >= UPGRADE_RETRIES)
    e9c8:	83 30       	cpi	r24, 0x03	; 3
    e9ca:	38 f0       	brcs	.+14     	; 0xe9da <main+0x178>
					{
						checkAppHeader();
    e9cc:	0e 94 af 73 	call	0xe75e	; 0xe75e <checkAppHeader>

						if (isAppValid)
    e9d0:	80 91 36 06 	lds	r24, 0x0636	; 0x800636 <isAppValid>
    e9d4:	81 11       	cpse	r24, r1
						{
							jump_to_app();
    e9d6:	0e 94 57 73 	call	0xe6ae	; 0xe6ae <jump_to_app>
						}
					}

					closeModem();
    e9da:	0e 94 24 7b 	call	0xf648	; 0xf648 <closeModem>
					PowerDown(false);
    e9de:	80 e0       	ldi	r24, 0x00	; 0
    e9e0:	0e 94 c4 72 	call	0xe588	; 0xe588 <PowerDown>
    e9e4:	b1 cf       	rjmp	.-158    	; 0xe948 <main+0xe6>

0000e9e6 <ReadAdc>:
//Do battery measuring

// Read the AD conversion result
unsigned int ReadAdc(BYTE mux)
{
    ADMUX = mux | ADC_VREF_TYPE;
    e9e6:	80 6c       	ori	r24, 0xC0	; 192
    e9e8:	80 93 7c 00 	sts	0x007C, r24	; 0x80007c <__DATA_REGION_ORIGIN__+0x1c>
    // Delay needed for the stabilization of the ADC input voltage
    delay_ms(1);
    e9ec:	81 e0       	ldi	r24, 0x01	; 1
    e9ee:	90 e0       	ldi	r25, 0x00	; 0
    e9f0:	0e 94 67 70 	call	0xe0ce	; 0xe0ce <delay_ms>
    // Start the AD conversion
    ADCSRA|=(1<<ADSC);
    e9f4:	80 91 7a 00 	lds	r24, 0x007A	; 0x80007a <__DATA_REGION_ORIGIN__+0x1a>
    e9f8:	80 64       	ori	r24, 0x40	; 64
    e9fa:	80 93 7a 00 	sts	0x007A, r24	; 0x80007a <__DATA_REGION_ORIGIN__+0x1a>
    // Wait for the AD conversion to complete
    while ((ADCSRA & (1<<ADIF))==0);
    e9fe:	80 91 7a 00 	lds	r24, 0x007A	; 0x80007a <__DATA_REGION_ORIGIN__+0x1a>
    ea02:	84 ff       	sbrs	r24, 4
    ea04:	fc cf       	rjmp	.-8      	; 0xe9fe <ReadAdc+0x18>
    ADCSRA|=(1<<ADIF);
    ea06:	80 91 7a 00 	lds	r24, 0x007A	; 0x80007a <__DATA_REGION_ORIGIN__+0x1a>
    ea0a:	80 61       	ori	r24, 0x10	; 16
    ea0c:	80 93 7a 00 	sts	0x007A, r24	; 0x80007a <__DATA_REGION_ORIGIN__+0x1a>
    return ADCW;
    ea10:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__DATA_REGION_ORIGIN__+0x18>
    ea14:	90 91 79 00 	lds	r25, 0x0079	; 0x800079 <__DATA_REGION_ORIGIN__+0x19>
}
    ea18:	08 95       	ret

0000ea1a <MeasureADC>:

unsigned int MeasureADC(BYTE mux)
{
    ea1a:	8f 92       	push	r8
    ea1c:	9f 92       	push	r9
    ea1e:	af 92       	push	r10
    ea20:	bf 92       	push	r11
    ea22:	cf 92       	push	r12
    ea24:	df 92       	push	r13
    ea26:	ef 92       	push	r14
    ea28:	ff 92       	push	r15
    ea2a:	0f 93       	push	r16
    ea2c:	1f 93       	push	r17
    ea2e:	cf 93       	push	r28
    ea30:	df 93       	push	r29
    ea32:	88 2e       	mov	r8, r24
    char i;
    unsigned int adc_res, hi_value, lo_value;
    unsigned long cur_value;
    ENABLE_ADC();
    ea34:	87 e8       	ldi	r24, 0x87	; 135
    ea36:	80 93 7a 00 	sts	0x007A, r24	; 0x80007a <__DATA_REGION_ORIGIN__+0x1a>
    delay_ms(10);
    ea3a:	8a e0       	ldi	r24, 0x0A	; 10
    ea3c:	90 e0       	ldi	r25, 0x00	; 0
    ea3e:	0e 94 67 70 	call	0xe0ce	; 0xe0ce <delay_ms>

    // enable ADC conversion
    ADCSRA|=(1<<ADEN);
    ea42:	80 91 7a 00 	lds	r24, 0x007A	; 0x80007a <__DATA_REGION_ORIGIN__+0x1a>
    ea46:	80 68       	ori	r24, 0x80	; 128
    ea48:	80 93 7a 00 	sts	0x007A, r24	; 0x80007a <__DATA_REGION_ORIGIN__+0x1a>
    ea4c:	4a e0       	ldi	r20, 0x0A	; 10
    ea4e:	94 2e       	mov	r9, r20

    hi_value = adc_res = 0;
    lo_value = 0xFFFF;
    ea50:	0f ef       	ldi	r16, 0xFF	; 255
    ea52:	1f ef       	ldi	r17, 0xFF	; 255
    delay_ms(10);

    // enable ADC conversion
    ADCSRA|=(1<<ADEN);

    hi_value = adc_res = 0;
    ea54:	a1 2c       	mov	r10, r1
    ea56:	b1 2c       	mov	r11, r1
    ea58:	c0 e0       	ldi	r28, 0x00	; 0
    ea5a:	d0 e0       	ldi	r29, 0x00	; 0
    lo_value = 0xFFFF;

    for(i = 0; i < 10; i++)
    {
        cur_value = ReadAdc(mux);
    ea5c:	88 2d       	mov	r24, r8
    ea5e:	0e 94 f3 74 	call	0xe9e6	; 0xe9e6 <ReadAdc>
        cur_value = (cur_value * INT_VREF)/1024L;
    ea62:	9c 01       	movw	r18, r24
    ea64:	a0 e0       	ldi	r26, 0x00	; 0
    ea66:	ba e0       	ldi	r27, 0x0A	; 10
    ea68:	0e 94 da 7b 	call	0xf7b4	; 0xf7b4 <__umulhisi3>
    ea6c:	6b 01       	movw	r12, r22
    ea6e:	7c 01       	movw	r14, r24
    ea70:	3a e0       	ldi	r19, 0x0A	; 10
    ea72:	f6 94       	lsr	r15
    ea74:	e7 94       	ror	r14
    ea76:	d7 94       	ror	r13
    ea78:	c7 94       	ror	r12
    ea7a:	3a 95       	dec	r19
    ea7c:	d1 f7       	brne	.-12     	; 0xea72 <MeasureADC+0x58>
        delay_ms(10);
    ea7e:	8a e0       	ldi	r24, 0x0A	; 10
    ea80:	90 e0       	ldi	r25, 0x00	; 0
    ea82:	0e 94 67 70 	call	0xe0ce	; 0xe0ce <delay_ms>
        if (hi_value < cur_value)
    ea86:	c5 01       	movw	r24, r10
    ea88:	a0 e0       	ldi	r26, 0x00	; 0
    ea8a:	b0 e0       	ldi	r27, 0x00	; 0
    ea8c:	8c 15       	cp	r24, r12
    ea8e:	9d 05       	cpc	r25, r13
    ea90:	ae 05       	cpc	r26, r14
    ea92:	bf 05       	cpc	r27, r15
    ea94:	08 f4       	brcc	.+2      	; 0xea98 <MeasureADC+0x7e>
            hi_value = (int)cur_value;
    ea96:	56 01       	movw	r10, r12
        if (lo_value > cur_value)
    ea98:	c8 01       	movw	r24, r16
    ea9a:	a0 e0       	ldi	r26, 0x00	; 0
    ea9c:	b0 e0       	ldi	r27, 0x00	; 0
    ea9e:	c8 16       	cp	r12, r24
    eaa0:	d9 06       	cpc	r13, r25
    eaa2:	ea 06       	cpc	r14, r26
    eaa4:	fb 06       	cpc	r15, r27
    eaa6:	08 f4       	brcc	.+2      	; 0xeaaa <MeasureADC+0x90>
            lo_value = (int)cur_value;
    eaa8:	86 01       	movw	r16, r12
        adc_res += cur_value;
    eaaa:	cc 0d       	add	r28, r12
    eaac:	dd 1d       	adc	r29, r13
    eaae:	9a 94       	dec	r9
    ADCSRA|=(1<<ADEN);

    hi_value = adc_res = 0;
    lo_value = 0xFFFF;

    for(i = 0; i < 10; i++)
    eab0:	91 10       	cpse	r9, r1
    eab2:	d4 cf       	rjmp	.-88     	; 0xea5c <MeasureADC+0x42>
            hi_value = (int)cur_value;
        if (lo_value > cur_value)
            lo_value = (int)cur_value;
        adc_res += cur_value;
    }
    adc_res = adc_res - hi_value;
    eab4:	ce 01       	movw	r24, r28
    eab6:	8a 19       	sub	r24, r10
    eab8:	9b 09       	sbc	r25, r11
    adc_res = adc_res - lo_value;
    eaba:	80 1b       	sub	r24, r16
    eabc:	91 0b       	sbc	r25, r17
    adc_res = adc_res / 8;
    DISABLE_ADC();
    eabe:	10 92 7a 00 	sts	0x007A, r1	; 0x80007a <__DATA_REGION_ORIGIN__+0x1a>
    return adc_res;
}
    eac2:	23 e0       	ldi	r18, 0x03	; 3
    eac4:	96 95       	lsr	r25
    eac6:	87 95       	ror	r24
    eac8:	2a 95       	dec	r18
    eaca:	e1 f7       	brne	.-8      	; 0xeac4 <MeasureADC+0xaa>
    eacc:	df 91       	pop	r29
    eace:	cf 91       	pop	r28
    ead0:	1f 91       	pop	r17
    ead2:	0f 91       	pop	r16
    ead4:	ff 90       	pop	r15
    ead6:	ef 90       	pop	r14
    ead8:	df 90       	pop	r13
    eada:	cf 90       	pop	r12
    eadc:	bf 90       	pop	r11
    eade:	af 90       	pop	r10
    eae0:	9f 90       	pop	r9
    eae2:	8f 90       	pop	r8
    eae4:	08 95       	ret

0000eae6 <MeasureBatt>:

void MeasureBatt()
{
    // Analog Comparator initialization
    // PortA analog inputs init
    DDRA &= ~1;
    eae6:	08 98       	cbi	0x01, 0	; 1
    PORTA &= ~1;
    eae8:	10 98       	cbi	0x02, 0	; 2

    iVoltage = MeasureADC(MUX_BATTERY);
    eaea:	81 e0       	ldi	r24, 0x01	; 1
    eaec:	0e 94 0d 75 	call	0xea1a	; 0xea1a <MeasureADC>
    iVoltage *= 2;
    iVoltage += 100;    // fix the offset of battery measurment.
    eaf0:	88 0f       	add	r24, r24
    eaf2:	99 1f       	adc	r25, r25
    eaf4:	8c 59       	subi	r24, 0x9C	; 156
    eaf6:	9f 4f       	sbci	r25, 0xFF	; 255
    eaf8:	90 93 40 06 	sts	0x0640, r25	; 0x800640 <iVoltage+0x1>
    eafc:	80 93 3f 06 	sts	0x063F, r24	; 0x80063f <iVoltage>

    _logd("BAT v: %d", iVoltage);
    eb00:	9f 93       	push	r25
    eb02:	8f 93       	push	r24
    eb04:	84 e0       	ldi	r24, 0x04	; 4
    eb06:	92 e0       	ldi	r25, 0x02	; 2
    eb08:	9f 93       	push	r25
    eb0a:	8f 93       	push	r24
    eb0c:	0e 94 aa 72 	call	0xe554	; 0xe554 <logd>
}
    eb10:	0f 90       	pop	r0
    eb12:	0f 90       	pop	r0
    eb14:	0f 90       	pop	r0
    eb16:	0f 90       	pop	r0
    eb18:	08 95       	ret

0000eb1a <parseMONIResponse>:
	{
		return false;
	}
	
	return status == 1;
}
    eb1a:	0f 93       	push	r16
    eb1c:	1f 93       	push	r17
    eb1e:	cf 93       	push	r28
    eb20:	df 93       	push	r29
    eb22:	cd b7       	in	r28, 0x3d	; 61
    eb24:	de b7       	in	r29, 0x3e	; 62
    eb26:	2a 97       	sbiw	r28, 0x0a	; 10
    eb28:	0f b6       	in	r0, 0x3f	; 63
    eb2a:	f8 94       	cli
    eb2c:	de bf       	out	0x3e, r29	; 62
    eb2e:	0f be       	out	0x3f, r0	; 63
    eb30:	cd bf       	out	0x3d, r28	; 61
    eb32:	fc 01       	movw	r30, r24
    eb34:	9f 01       	movw	r18, r30
    eb36:	81 91       	ld	r24, Z+
    eb38:	81 11       	cpse	r24, r1
    eb3a:	02 c0       	rjmp	.+4      	; 0xeb40 <parseMONIResponse+0x26>
    eb3c:	80 e0       	ldi	r24, 0x00	; 0
    eb3e:	2e c0       	rjmp	.+92     	; 0xeb9c <parseMONIResponse+0x82>
    eb40:	89 34       	cpi	r24, 0x49	; 73
    eb42:	c1 f7       	brne	.-16     	; 0xeb34 <parseMONIResponse+0x1a>
    eb44:	80 81       	ld	r24, Z
    eb46:	84 36       	cpi	r24, 0x64	; 100
    eb48:	a9 f7       	brne	.-22     	; 0xeb34 <parseMONIResponse+0x1a>
    eb4a:	81 81       	ldd	r24, Z+1	; 0x01
    eb4c:	8a 33       	cpi	r24, 0x3A	; 58
    eb4e:	91 f7       	brne	.-28     	; 0xeb34 <parseMONIResponse+0x1a>
    eb50:	8e 01       	movw	r16, r28
    eb52:	0f 5f       	subi	r16, 0xFF	; 255
    eb54:	1f 4f       	sbci	r17, 0xFF	; 255
    eb56:	1f 93       	push	r17
    eb58:	0f 93       	push	r16
    eb5a:	8e e0       	ldi	r24, 0x0E	; 14
    eb5c:	92 e0       	ldi	r25, 0x02	; 2
    eb5e:	9f 93       	push	r25
    eb60:	8f 93       	push	r24
    eb62:	3f 93       	push	r19
    eb64:	2f 93       	push	r18
    eb66:	0e 94 3e 71 	call	0xe27c	; 0xe27c <qscanf>
    eb6a:	0f 90       	pop	r0
    eb6c:	0f 90       	pop	r0
    eb6e:	0f 90       	pop	r0
    eb70:	0f 90       	pop	r0
    eb72:	0f 90       	pop	r0
    eb74:	0f 90       	pop	r0
    eb76:	01 97       	sbiw	r24, 0x01	; 1
    eb78:	09 f7       	brne	.-62     	; 0xeb3c <parseMONIResponse+0x22>
    eb7a:	f8 01       	movw	r30, r16
    eb7c:	ac ed       	ldi	r26, 0xDC	; 220
    eb7e:	be e0       	ldi	r27, 0x0E	; 14
    eb80:	9e 01       	movw	r18, r28
    eb82:	2a 5f       	subi	r18, 0xFA	; 250
    eb84:	3f 4f       	sbci	r19, 0xFF	; 255
    eb86:	81 91       	ld	r24, Z+
    eb88:	81 11       	cpse	r24, r1
    eb8a:	01 c0       	rjmp	.+2      	; 0xeb8e <parseMONIResponse+0x74>
    eb8c:	8a e2       	ldi	r24, 0x2A	; 42
    eb8e:	8d 93       	st	X+, r24
    eb90:	2e 17       	cp	r18, r30
    eb92:	3f 07       	cpc	r19, r31
    eb94:	c1 f7       	brne	.-16     	; 0xeb86 <parseMONIResponse+0x6c>
    eb96:	10 92 e1 0e 	sts	0x0EE1, r1	; 0x800ee1 <CellID+0x5>
    eb9a:	81 e0       	ldi	r24, 0x01	; 1
    eb9c:	2a 96       	adiw	r28, 0x0a	; 10
    eb9e:	0f b6       	in	r0, 0x3f	; 63
    eba0:	f8 94       	cli
    eba2:	de bf       	out	0x3e, r29	; 62
    eba4:	0f be       	out	0x3f, r0	; 63
    eba6:	cd bf       	out	0x3d, r28	; 61
    eba8:	df 91       	pop	r29
    ebaa:	cf 91       	pop	r28
    ebac:	1f 91       	pop	r17
    ebae:	0f 91       	pop	r16
    ebb0:	08 95       	ret

0000ebb2 <parseCSQResponse>:
    ebb2:	cf 93       	push	r28
    ebb4:	df 93       	push	r29
    ebb6:	00 d0       	rcall	.+0      	; 0xebb8 <parseCSQResponse+0x6>
    ebb8:	cd b7       	in	r28, 0x3d	; 61
    ebba:	de b7       	in	r29, 0x3e	; 62
    ebbc:	9e 01       	movw	r18, r28
    ebbe:	2f 5f       	subi	r18, 0xFF	; 255
    ebc0:	3f 4f       	sbci	r19, 0xFF	; 255
    ebc2:	3f 93       	push	r19
    ebc4:	2f 93       	push	r18
    ebc6:	2f 5f       	subi	r18, 0xFF	; 255
    ebc8:	3f 4f       	sbci	r19, 0xFF	; 255
    ebca:	3f 93       	push	r19
    ebcc:	2f 93       	push	r18
    ebce:	25 e1       	ldi	r18, 0x15	; 21
    ebd0:	32 e0       	ldi	r19, 0x02	; 2
    ebd2:	3f 93       	push	r19
    ebd4:	2f 93       	push	r18
    ebd6:	9f 93       	push	r25
    ebd8:	8f 93       	push	r24
    ebda:	0e 94 3e 71 	call	0xe27c	; 0xe27c <qscanf>
    ebde:	0f b6       	in	r0, 0x3f	; 63
    ebe0:	f8 94       	cli
    ebe2:	de bf       	out	0x3e, r29	; 62
    ebe4:	0f be       	out	0x3f, r0	; 63
    ebe6:	cd bf       	out	0x3d, r28	; 61
    ebe8:	02 97       	sbiw	r24, 0x02	; 2
    ebea:	29 f4       	brne	.+10     	; 0xebf6 <parseCSQResponse+0x44>
    ebec:	8a 81       	ldd	r24, Y+2	; 0x02
    ebee:	80 93 e2 0e 	sts	0x0EE2, r24	; 0x800ee2 <rssi_val>
    ebf2:	81 e0       	ldi	r24, 0x01	; 1
    ebf4:	01 c0       	rjmp	.+2      	; 0xebf8 <parseCSQResponse+0x46>
    ebf6:	80 e0       	ldi	r24, 0x00	; 0
    ebf8:	0f 90       	pop	r0
    ebfa:	0f 90       	pop	r0
    ebfc:	df 91       	pop	r29
    ebfe:	cf 91       	pop	r28
    ec00:	08 95       	ret

0000ec02 <parseCOPSResponse>:
    ec02:	2f 92       	push	r2
    ec04:	3f 92       	push	r3
    ec06:	4f 92       	push	r4
    ec08:	5f 92       	push	r5
    ec0a:	6f 92       	push	r6
    ec0c:	7f 92       	push	r7
    ec0e:	8f 92       	push	r8
    ec10:	9f 92       	push	r9
    ec12:	af 92       	push	r10
    ec14:	bf 92       	push	r11
    ec16:	cf 92       	push	r12
    ec18:	df 92       	push	r13
    ec1a:	ef 92       	push	r14
    ec1c:	ff 92       	push	r15
    ec1e:	0f 93       	push	r16
    ec20:	1f 93       	push	r17
    ec22:	cf 93       	push	r28
    ec24:	df 93       	push	r29
    ec26:	cd b7       	in	r28, 0x3d	; 61
    ec28:	de b7       	in	r29, 0x3e	; 62
    ec2a:	2e 97       	sbiw	r28, 0x0e	; 14
    ec2c:	0f b6       	in	r0, 0x3f	; 63
    ec2e:	f8 94       	cli
    ec30:	de bf       	out	0x3e, r29	; 62
    ec32:	0f be       	out	0x3f, r0	; 63
    ec34:	cd bf       	out	0x3d, r28	; 61
    ec36:	9e 87       	std	Y+14, r25	; 0x0e
    ec38:	8d 87       	std	Y+13, r24	; 0x0d
    ec3a:	8e 01       	movw	r16, r28
    ec3c:	03 5f       	subi	r16, 0xF3	; 243
    ec3e:	1f 4f       	sbci	r17, 0xFF	; 255
    ec40:	1f 93       	push	r17
    ec42:	0f 93       	push	r16
    ec44:	81 e2       	ldi	r24, 0x21	; 33
    ec46:	92 e0       	ldi	r25, 0x02	; 2
    ec48:	9f 93       	push	r25
    ec4a:	8f 93       	push	r24
    ec4c:	8e 85       	ldd	r24, Y+14	; 0x0e
    ec4e:	8f 93       	push	r24
    ec50:	8d 85       	ldd	r24, Y+13	; 0x0d
    ec52:	8f 93       	push	r24
    ec54:	0e 94 3e 71 	call	0xe27c	; 0xe27c <qscanf>
    ec58:	0f 90       	pop	r0
    ec5a:	0f 90       	pop	r0
    ec5c:	0f 90       	pop	r0
    ec5e:	0f 90       	pop	r0
    ec60:	0f 90       	pop	r0
    ec62:	0f 90       	pop	r0
    ec64:	01 97       	sbiw	r24, 0x01	; 1
    ec66:	09 f0       	breq	.+2      	; 0xec6a <parseCOPSResponse+0x68>
    ec68:	65 c0       	rjmp	.+202    	; 0xed34 <parseCOPSResponse+0x132>
    ec6a:	41 2c       	mov	r4, r1
    ec6c:	3e 01       	movw	r6, r28
    ec6e:	2b e0       	ldi	r18, 0x0B	; 11
    ec70:	62 0e       	add	r6, r18
    ec72:	71 1c       	adc	r7, r1
    ec74:	ce 01       	movw	r24, r28
    ec76:	01 96       	adiw	r24, 0x01	; 1
    ec78:	7c 01       	movw	r14, r24
    ec7a:	5e 01       	movw	r10, r28
    ec7c:	9c e0       	ldi	r25, 0x0C	; 12
    ec7e:	a9 0e       	add	r10, r25
    ec80:	b1 1c       	adc	r11, r1
    ec82:	9b e2       	ldi	r25, 0x2B	; 43
    ec84:	89 2e       	mov	r8, r25
    ec86:	92 e0       	ldi	r25, 0x02	; 2
    ec88:	99 2e       	mov	r9, r25
    ec8a:	2c e0       	ldi	r18, 0x0C	; 12
    ec8c:	32 2e       	mov	r3, r18
    ec8e:	ed 85       	ldd	r30, Y+13	; 0x0d
    ec90:	fe 85       	ldd	r31, Y+14	; 0x0e
    ec92:	80 81       	ld	r24, Z
    ec94:	88 32       	cpi	r24, 0x28	; 40
    ec96:	09 f0       	breq	.+2      	; 0xec9a <parseCOPSResponse+0x98>
    ec98:	4a c0       	rjmp	.+148    	; 0xed2e <parseCOPSResponse+0x12c>
    ec9a:	1f 93       	push	r17
    ec9c:	0f 93       	push	r16
    ec9e:	7f 92       	push	r7
    eca0:	6f 92       	push	r6
    eca2:	ff 92       	push	r15
    eca4:	ef 92       	push	r14
    eca6:	1f 92       	push	r1
    eca8:	1f 92       	push	r1
    ecaa:	bf 92       	push	r11
    ecac:	af 92       	push	r10
    ecae:	9f 92       	push	r9
    ecb0:	8f 92       	push	r8
    ecb2:	ff 93       	push	r31
    ecb4:	ef 93       	push	r30
    ecb6:	0e 94 3e 71 	call	0xe27c	; 0xe27c <qscanf>
    ecba:	0f b6       	in	r0, 0x3f	; 63
    ecbc:	f8 94       	cli
    ecbe:	de bf       	out	0x3e, r29	; 62
    ecc0:	0f be       	out	0x3f, r0	; 63
    ecc2:	cd bf       	out	0x3d, r28	; 61
    ecc4:	05 97       	sbiw	r24, 0x05	; 5
    ecc6:	99 f5       	brne	.+102    	; 0xed2e <parseCOPSResponse+0x12c>
    ecc8:	20 90 6c 05 	lds	r2, 0x056C	; 0x80056c <numOprt>
    eccc:	39 e0       	ldi	r19, 0x09	; 9
    ecce:	32 15       	cp	r19, r2
    ecd0:	28 f1       	brcs	.+74     	; 0xed1c <parseCOPSResponse+0x11a>
    ecd2:	86 e6       	ldi	r24, 0x66	; 102
    ecd4:	c8 2e       	mov	r12, r24
    ecd6:	8e e0       	ldi	r24, 0x0E	; 14
    ecd8:	d8 2e       	mov	r13, r24
    ecda:	51 2c       	mov	r5, r1
    ecdc:	52 14       	cp	r5, r2
    ecde:	59 f0       	breq	.+22     	; 0xecf6 <parseCOPSResponse+0xf4>
    ece0:	b7 01       	movw	r22, r14
    ece2:	c6 01       	movw	r24, r12
    ece4:	0e 94 f2 7b 	call	0xf7e4	; 0xf7e4 <strcmp>
    ece8:	2c e0       	ldi	r18, 0x0C	; 12
    ecea:	c2 0e       	add	r12, r18
    ecec:	d1 1c       	adc	r13, r1
    ecee:	89 2b       	or	r24, r25
    ecf0:	a9 f0       	breq	.+42     	; 0xed1c <parseCOPSResponse+0x11a>
    ecf2:	53 94       	inc	r5
    ecf4:	f3 cf       	rjmp	.-26     	; 0xecdc <parseCOPSResponse+0xda>
    ecf6:	35 9c       	mul	r3, r5
    ecf8:	c0 01       	movw	r24, r0
    ecfa:	11 24       	eor	r1, r1
    ecfc:	fc 01       	movw	r30, r24
    ecfe:	ec 59       	subi	r30, 0x9C	; 156
    ed00:	f1 4f       	sbci	r31, 0xF1	; 241
    ed02:	2c 85       	ldd	r18, Y+12	; 0x0c
    ed04:	20 83       	st	Z, r18
    ed06:	2b 85       	ldd	r18, Y+11	; 0x0b
    ed08:	21 83       	std	Z+1, r18	; 0x01
    ed0a:	b7 01       	movw	r22, r14
    ed0c:	8a 59       	subi	r24, 0x9A	; 154
    ed0e:	91 4f       	sbci	r25, 0xF1	; 241
    ed10:	0e 94 fb 7b 	call	0xf7f6	; 0xf7f6 <strcpy>
    ed14:	53 94       	inc	r5
    ed16:	50 92 6c 05 	sts	0x056C, r5	; 0x80056c <numOprt>
    ed1a:	43 94       	inc	r4
    ed1c:	ed 85       	ldd	r30, Y+13	; 0x0d
    ed1e:	fe 85       	ldd	r31, Y+14	; 0x0e
    ed20:	80 81       	ld	r24, Z
    ed22:	8c 32       	cpi	r24, 0x2C	; 44
    ed24:	21 f4       	brne	.+8      	; 0xed2e <parseCOPSResponse+0x12c>
    ed26:	31 96       	adiw	r30, 0x01	; 1
    ed28:	fe 87       	std	Y+14, r31	; 0x0e
    ed2a:	ed 87       	std	Y+13, r30	; 0x0d
    ed2c:	b0 cf       	rjmp	.-160    	; 0xec8e <parseCOPSResponse+0x8c>
    ed2e:	81 e0       	ldi	r24, 0x01	; 1
    ed30:	41 10       	cpse	r4, r1
    ed32:	01 c0       	rjmp	.+2      	; 0xed36 <parseCOPSResponse+0x134>
    ed34:	80 e0       	ldi	r24, 0x00	; 0
    ed36:	2e 96       	adiw	r28, 0x0e	; 14
    ed38:	0f b6       	in	r0, 0x3f	; 63
    ed3a:	f8 94       	cli
    ed3c:	de bf       	out	0x3e, r29	; 62
    ed3e:	0f be       	out	0x3f, r0	; 63
    ed40:	cd bf       	out	0x3d, r28	; 61
    ed42:	df 91       	pop	r29
    ed44:	cf 91       	pop	r28
    ed46:	1f 91       	pop	r17
    ed48:	0f 91       	pop	r16
    ed4a:	ff 90       	pop	r15
    ed4c:	ef 90       	pop	r14
    ed4e:	df 90       	pop	r13
    ed50:	cf 90       	pop	r12
    ed52:	bf 90       	pop	r11
    ed54:	af 90       	pop	r10
    ed56:	9f 90       	pop	r9
    ed58:	8f 90       	pop	r8
    ed5a:	7f 90       	pop	r7
    ed5c:	6f 90       	pop	r6
    ed5e:	5f 90       	pop	r5
    ed60:	4f 90       	pop	r4
    ed62:	3f 90       	pop	r3
    ed64:	2f 90       	pop	r2
    ed66:	08 95       	ret

0000ed68 <getResponse>:
    ed68:	8b e4       	ldi	r24, 0x4B	; 75
    ed6a:	96 e0       	ldi	r25, 0x06	; 6
    ed6c:	08 95       	ret

0000ed6e <getHttpBody>:
    ed6e:	80 91 4d 0e 	lds	r24, 0x0E4D	; 0x800e4d <httpBodyStart>
    ed72:	90 91 4e 0e 	lds	r25, 0x0E4E	; 0x800e4e <httpBodyStart+0x1>
    ed76:	97 fd       	sbrc	r25, 7
    ed78:	03 c0       	rjmp	.+6      	; 0xed80 <getHttpBody+0x12>
    ed7a:	85 5b       	subi	r24, 0xB5	; 181
    ed7c:	99 4f       	sbci	r25, 0xF9	; 249
    ed7e:	08 95       	ret
    ed80:	80 e0       	ldi	r24, 0x00	; 0
    ed82:	90 e0       	ldi	r25, 0x00	; 0
    ed84:	08 95       	ret

0000ed86 <getHttpBodyLength>:
    ed86:	20 91 4d 0e 	lds	r18, 0x0E4D	; 0x800e4d <httpBodyStart>
    ed8a:	30 91 4e 0e 	lds	r19, 0x0E4E	; 0x800e4e <httpBodyStart+0x1>
    ed8e:	37 fd       	sbrc	r19, 7
    ed90:	07 c0       	rjmp	.+14     	; 0xeda0 <getHttpBodyLength+0x1a>
    ed92:	80 91 4b 0e 	lds	r24, 0x0E4B	; 0x800e4b <atCommandCount>
    ed96:	90 91 4c 0e 	lds	r25, 0x0E4C	; 0x800e4c <atCommandCount+0x1>
    ed9a:	82 1b       	sub	r24, r18
    ed9c:	93 0b       	sbc	r25, r19
    ed9e:	08 95       	ret
    eda0:	80 e0       	ldi	r24, 0x00	; 0
    eda2:	90 e0       	ldi	r25, 0x00	; 0
    eda4:	08 95       	ret

0000eda6 <turnOnIgnition>:
    eda6:	44 9a       	sbi	0x08, 4	; 8
    eda8:	08 95       	ret

0000edaa <turnOffIgnition>:
    edaa:	44 98       	cbi	0x08, 4	; 8
    edac:	08 95       	ret

0000edae <modemHwShdn>:
    edae:	5f 98       	cbi	0x0b, 7	; 11
    edb0:	08 95       	ret

0000edb2 <isModemOn>:
    edb2:	86 b1       	in	r24, 0x06	; 6
    edb4:	86 fb       	bst	r24, 6
    edb6:	88 27       	eor	r24, r24
    edb8:	80 f9       	bld	r24, 0
    edba:	91 e0       	ldi	r25, 0x01	; 1
    edbc:	89 27       	eor	r24, r25
    edbe:	08 95       	ret

0000edc0 <IsOK>:
    edc0:	20 e4       	ldi	r18, 0x40	; 64
    edc2:	32 e0       	ldi	r19, 0x02	; 2
    edc4:	3f 93       	push	r19
    edc6:	2f 93       	push	r18
    edc8:	9f 93       	push	r25
    edca:	8f 93       	push	r24
    edcc:	0e 94 3e 71 	call	0xe27c	; 0xe27c <qscanf>
    edd0:	21 e0       	ldi	r18, 0x01	; 1
    edd2:	0f 90       	pop	r0
    edd4:	0f 90       	pop	r0
    edd6:	0f 90       	pop	r0
    edd8:	0f 90       	pop	r0
    edda:	01 97       	sbiw	r24, 0x01	; 1
    eddc:	09 f0       	breq	.+2      	; 0xede0 <IsOK+0x20>
    edde:	20 e0       	ldi	r18, 0x00	; 0
    ede0:	82 2f       	mov	r24, r18
    ede2:	08 95       	ret

0000ede4 <IsError>:
    ede4:	28 e4       	ldi	r18, 0x48	; 72
    ede6:	32 e0       	ldi	r19, 0x02	; 2
    ede8:	3f 93       	push	r19
    edea:	2f 93       	push	r18
    edec:	9f 93       	push	r25
    edee:	8f 93       	push	r24
    edf0:	0e 94 3e 71 	call	0xe27c	; 0xe27c <qscanf>
    edf4:	21 e0       	ldi	r18, 0x01	; 1
    edf6:	0f 90       	pop	r0
    edf8:	0f 90       	pop	r0
    edfa:	0f 90       	pop	r0
    edfc:	0f 90       	pop	r0
    edfe:	01 97       	sbiw	r24, 0x01	; 1
    ee00:	09 f0       	breq	.+2      	; 0xee04 <IsError+0x20>
    ee02:	20 e0       	ldi	r18, 0x00	; 0
    ee04:	82 2f       	mov	r24, r18
    ee06:	08 95       	ret

0000ee08 <IsConnect>:
    ee08:	23 e5       	ldi	r18, 0x53	; 83
    ee0a:	32 e0       	ldi	r19, 0x02	; 2
    ee0c:	3f 93       	push	r19
    ee0e:	2f 93       	push	r18
    ee10:	9f 93       	push	r25
    ee12:	8f 93       	push	r24
    ee14:	0e 94 3e 71 	call	0xe27c	; 0xe27c <qscanf>
    ee18:	21 e0       	ldi	r18, 0x01	; 1
    ee1a:	0f 90       	pop	r0
    ee1c:	0f 90       	pop	r0
    ee1e:	0f 90       	pop	r0
    ee20:	0f 90       	pop	r0
    ee22:	01 97       	sbiw	r24, 0x01	; 1
    ee24:	09 f0       	breq	.+2      	; 0xee28 <IsConnect+0x20>
    ee26:	20 e0       	ldi	r18, 0x00	; 0
    ee28:	82 2f       	mov	r24, r18
    ee2a:	08 95       	ret

0000ee2c <IsReady>:
    ee2c:	20 e6       	ldi	r18, 0x60	; 96
    ee2e:	32 e0       	ldi	r19, 0x02	; 2
    ee30:	3f 93       	push	r19
    ee32:	2f 93       	push	r18
    ee34:	9f 93       	push	r25
    ee36:	8f 93       	push	r24
    ee38:	0e 94 3e 71 	call	0xe27c	; 0xe27c <qscanf>
    ee3c:	21 e0       	ldi	r18, 0x01	; 1
    ee3e:	0f 90       	pop	r0
    ee40:	0f 90       	pop	r0
    ee42:	0f 90       	pop	r0
    ee44:	0f 90       	pop	r0
    ee46:	01 97       	sbiw	r24, 0x01	; 1
    ee48:	09 f0       	breq	.+2      	; 0xee4c <IsReady+0x20>
    ee4a:	20 e0       	ldi	r18, 0x00	; 0
    ee4c:	82 2f       	mov	r24, r18
    ee4e:	08 95       	ret

0000ee50 <modemRx>:
    ee50:	80 91 c0 00 	lds	r24, 0x00C0	; 0x8000c0 <__DATA_REGION_ORIGIN__+0x60>
    ee54:	87 ff       	sbrs	r24, 7
    ee56:	08 c0       	rjmp	.+16     	; 0xee68 <modemRx+0x18>
    ee58:	90 91 c0 00 	lds	r25, 0x00C0	; 0x8000c0 <__DATA_REGION_ORIGIN__+0x60>
    ee5c:	80 91 c6 00 	lds	r24, 0x00C6	; 0x8000c6 <__DATA_REGION_ORIGIN__+0x66>
    ee60:	9c 71       	andi	r25, 0x1C	; 28
    ee62:	11 f4       	brne	.+4      	; 0xee68 <modemRx+0x18>
    ee64:	90 e0       	ldi	r25, 0x00	; 0
    ee66:	08 95       	ret
    ee68:	8f ef       	ldi	r24, 0xFF	; 255
    ee6a:	9f ef       	ldi	r25, 0xFF	; 255
    ee6c:	08 95       	ret

0000ee6e <sendRaw>:
    ee6e:	7f 92       	push	r7
    ee70:	8f 92       	push	r8
    ee72:	9f 92       	push	r9
    ee74:	af 92       	push	r10
    ee76:	bf 92       	push	r11
    ee78:	cf 92       	push	r12
    ee7a:	df 92       	push	r13
    ee7c:	ef 92       	push	r14
    ee7e:	ff 92       	push	r15
    ee80:	0f 93       	push	r16
    ee82:	1f 93       	push	r17
    ee84:	cf 93       	push	r28
    ee86:	df 93       	push	r29
    ee88:	f8 2e       	mov	r15, r24
    ee8a:	c9 2f       	mov	r28, r25
    ee8c:	8b 01       	movw	r16, r22
    ee8e:	5a 01       	movw	r10, r20
    ee90:	d2 2f       	mov	r29, r18
    ee92:	8e e3       	ldi	r24, 0x3E	; 62
    ee94:	0e 94 90 72 	call	0xe520	; 0xe520 <logTx>
    ee98:	8f 2d       	mov	r24, r15
    ee9a:	9c 2f       	mov	r25, r28
    ee9c:	0e 94 97 72 	call	0xe52e	; 0xe52e <logStrRaw>
    eea0:	a8 95       	wdr
    eea2:	ef 2d       	mov	r30, r15
    eea4:	fc 2f       	mov	r31, r28
    eea6:	81 91       	ld	r24, Z+
    eea8:	88 23       	and	r24, r24
    eeaa:	49 f0       	breq	.+18     	; 0xeebe <sendRaw+0x50>
    eeac:	90 91 c0 00 	lds	r25, 0x00C0	; 0x8000c0 <__DATA_REGION_ORIGIN__+0x60>
    eeb0:	95 fd       	sbrc	r25, 5
    eeb2:	02 c0       	rjmp	.+4      	; 0xeeb8 <sendRaw+0x4a>
    eeb4:	00 00       	nop
    eeb6:	fa cf       	rjmp	.-12     	; 0xeeac <sendRaw+0x3e>
    eeb8:	80 93 c6 00 	sts	0x00C6, r24	; 0x8000c6 <__DATA_REGION_ORIGIN__+0x66>
    eebc:	f4 cf       	rjmp	.-24     	; 0xeea6 <sendRaw+0x38>
    eebe:	c0 90 6d 05 	lds	r12, 0x056D	; 0x80056d <ms100>
    eec2:	d0 90 6e 05 	lds	r13, 0x056E	; 0x80056e <ms100+0x1>
    eec6:	8a e0       	ldi	r24, 0x0A	; 10
    eec8:	80 9f       	mul	r24, r16
    eeca:	70 01       	movw	r14, r0
    eecc:	81 9f       	mul	r24, r17
    eece:	f0 0c       	add	r15, r0
    eed0:	11 24       	eor	r1, r1
    eed2:	10 92 4b 06 	sts	0x064B, r1	; 0x80064b <atCommand>
    eed6:	10 92 4c 0e 	sts	0x0E4C, r1	; 0x800e4c <atCommandCount+0x1>
    eeda:	10 92 4b 0e 	sts	0x0E4B, r1	; 0x800e4b <atCommandCount>
    eede:	c0 e0       	ldi	r28, 0x00	; 0
    eee0:	00 e0       	ldi	r16, 0x00	; 0
    eee2:	10 e0       	ldi	r17, 0x00	; 0
    eee4:	a8 95       	wdr
    eee6:	80 91 6d 05 	lds	r24, 0x056D	; 0x80056d <ms100>
    eeea:	90 91 6e 05 	lds	r25, 0x056E	; 0x80056e <ms100+0x1>
    eeee:	8c 19       	sub	r24, r12
    eef0:	9d 09       	sbc	r25, r13
    eef2:	8e 15       	cp	r24, r14
    eef4:	9f 05       	cpc	r25, r15
    eef6:	18 f0       	brcs	.+6      	; 0xeefe <sendRaw+0x90>
    eef8:	d1 11       	cpse	r29, r1
    eefa:	61 c0       	rjmp	.+194    	; 0xefbe <sendRaw+0x150>
    eefc:	cf c0       	rjmp	.+414    	; 0xf09c <sendRaw+0x22e>
    eefe:	0e 94 28 77 	call	0xee50	; 0xee50 <modemRx>
    ef02:	97 fd       	sbrc	r25, 7
    ef04:	ef cf       	rjmp	.-34     	; 0xeee4 <sendRaw+0x76>
    ef06:	68 2f       	mov	r22, r24
    ef08:	20 91 4b 0e 	lds	r18, 0x0E4B	; 0x800e4b <atCommandCount>
    ef0c:	30 91 4c 0e 	lds	r19, 0x0E4C	; 0x800e4c <atCommandCount+0x1>
    ef10:	2f 3f       	cpi	r18, 0xFF	; 255
    ef12:	37 40       	sbci	r19, 0x07	; 7
    ef14:	20 f0       	brcs	.+8      	; 0xef1e <sendRaw+0xb0>
    ef16:	10 92 4c 0e 	sts	0x0E4C, r1	; 0x800e4c <atCommandCount+0x1>
    ef1a:	10 92 4b 0e 	sts	0x0E4B, r1	; 0x800e4b <atCommandCount>
    ef1e:	40 91 4b 0e 	lds	r20, 0x0E4B	; 0x800e4b <atCommandCount>
    ef22:	50 91 4c 0e 	lds	r21, 0x0E4C	; 0x800e4c <atCommandCount+0x1>
    ef26:	9a 01       	movw	r18, r20
    ef28:	2f 5f       	subi	r18, 0xFF	; 255
    ef2a:	3f 4f       	sbci	r19, 0xFF	; 255
    ef2c:	30 93 4c 0e 	sts	0x0E4C, r19	; 0x800e4c <atCommandCount+0x1>
    ef30:	20 93 4b 0e 	sts	0x0E4B, r18	; 0x800e4b <atCommandCount>
    ef34:	fa 01       	movw	r30, r20
    ef36:	e5 5b       	subi	r30, 0xB5	; 181
    ef38:	f9 4f       	sbci	r31, 0xF9	; 249
    ef3a:	80 83       	st	Z, r24
    ef3c:	f9 01       	movw	r30, r18
    ef3e:	e5 5b       	subi	r30, 0xB5	; 181
    ef40:	f9 4f       	sbci	r31, 0xF9	; 249
    ef42:	10 82       	st	Z, r1
    ef44:	d1 30       	cpi	r29, 0x01	; 1
    ef46:	49 f4       	brne	.+18     	; 0xef5a <sendRaw+0xec>
    ef48:	cc 23       	and	r28, r28
    ef4a:	39 f0       	breq	.+14     	; 0xef5a <sendRaw+0xec>
    ef4c:	c0 90 6d 05 	lds	r12, 0x056D	; 0x80056d <ms100>
    ef50:	d0 90 6e 05 	lds	r13, 0x056E	; 0x80056e <ms100+0x1>
    ef54:	42 e0       	ldi	r20, 0x02	; 2
    ef56:	e4 2e       	mov	r14, r20
    ef58:	f1 2c       	mov	r15, r1
    ef5a:	6a 30       	cpi	r22, 0x0A	; 10
    ef5c:	19 f6       	brne	.-122    	; 0xeee4 <sendRaw+0x76>
    ef5e:	20 1b       	sub	r18, r16
    ef60:	31 0b       	sbc	r19, r17
    ef62:	23 30       	cpi	r18, 0x03	; 3
    ef64:	31 05       	cpc	r19, r1
    ef66:	4c f4       	brge	.+18     	; 0xef7a <sendRaw+0x10c>
    ef68:	c0 90 6d 05 	lds	r12, 0x056D	; 0x80056d <ms100>
    ef6c:	d0 90 6e 05 	lds	r13, 0x056E	; 0x80056e <ms100+0x1>
    ef70:	c1 e0       	ldi	r28, 0x01	; 1
    ef72:	92 e0       	ldi	r25, 0x02	; 2
    ef74:	e9 2e       	mov	r14, r25
    ef76:	f1 2c       	mov	r15, r1
    ef78:	1d c0       	rjmp	.+58     	; 0xefb4 <sendRaw+0x146>
    ef7a:	d1 11       	cpse	r29, r1
    ef7c:	1b c0       	rjmp	.+54     	; 0xefb4 <sendRaw+0x146>
    ef7e:	05 5b       	subi	r16, 0xB5	; 181
    ef80:	19 4f       	sbci	r17, 0xF9	; 249
    ef82:	c8 01       	movw	r24, r16
    ef84:	0e 94 e0 76 	call	0xedc0	; 0xedc0 <IsOK>
    ef88:	81 11       	cpse	r24, r1
    ef8a:	19 c0       	rjmp	.+50     	; 0xefbe <sendRaw+0x150>
    ef8c:	c8 01       	movw	r24, r16
    ef8e:	0e 94 f2 76 	call	0xede4	; 0xede4 <IsError>
    ef92:	88 23       	and	r24, r24
    ef94:	29 f0       	breq	.+10     	; 0xefa0 <sendRaw+0x132>
    ef96:	89 e6       	ldi	r24, 0x69	; 105
    ef98:	92 e0       	ldi	r25, 0x02	; 2
    ef9a:	0e 94 a4 72 	call	0xe548	; 0xe548 <logStr>
    ef9e:	7e c0       	rjmp	.+252    	; 0xf09c <sendRaw+0x22e>
    efa0:	c8 01       	movw	r24, r16
    efa2:	0e 94 04 77 	call	0xee08	; 0xee08 <IsConnect>
    efa6:	81 11       	cpse	r24, r1
    efa8:	0a c0       	rjmp	.+20     	; 0xefbe <sendRaw+0x150>
    efaa:	c8 01       	movw	r24, r16
    efac:	0e 94 16 77 	call	0xee2c	; 0xee2c <IsReady>
    efb0:	81 11       	cpse	r24, r1
    efb2:	05 c0       	rjmp	.+10     	; 0xefbe <sendRaw+0x150>
    efb4:	00 91 4b 0e 	lds	r16, 0x0E4B	; 0x800e4b <atCommandCount>
    efb8:	10 91 4c 0e 	lds	r17, 0x0E4C	; 0x800e4c <atCommandCount+0x1>
    efbc:	93 cf       	rjmp	.-218    	; 0xeee4 <sendRaw+0x76>
    efbe:	8f ef       	ldi	r24, 0xFF	; 255
    efc0:	9f ef       	ldi	r25, 0xFF	; 255
    efc2:	90 93 4e 0e 	sts	0x0E4E, r25	; 0x800e4e <httpBodyStart+0x1>
    efc6:	80 93 4d 0e 	sts	0x0E4D, r24	; 0x800e4d <httpBodyStart>
    efca:	8b e4       	ldi	r24, 0x4B	; 75
    efcc:	e8 2e       	mov	r14, r24
    efce:	86 e0       	ldi	r24, 0x06	; 6
    efd0:	f8 2e       	mov	r15, r24
    efd2:	00 e0       	ldi	r16, 0x00	; 0
    efd4:	10 e0       	ldi	r17, 0x00	; 0
    efd6:	81 2c       	mov	r8, r1
    efd8:	91 2c       	mov	r9, r1
    efda:	c0 e0       	ldi	r28, 0x00	; 0
    efdc:	80 91 4b 0e 	lds	r24, 0x0E4B	; 0x800e4b <atCommandCount>
    efe0:	90 91 4c 0e 	lds	r25, 0x0E4C	; 0x800e4c <atCommandCount+0x1>
    efe4:	08 17       	cp	r16, r24
    efe6:	19 07       	cpc	r17, r25
    efe8:	0c f0       	brlt	.+2      	; 0xefec <sendRaw+0x17e>
    efea:	46 c0       	rjmp	.+140    	; 0xf078 <sendRaw+0x20a>
    efec:	0f 5f       	subi	r16, 0xFF	; 255
    efee:	1f 4f       	sbci	r17, 0xFF	; 255
    eff0:	f7 01       	movw	r30, r14
    eff2:	81 91       	ld	r24, Z+
    eff4:	7f 01       	movw	r14, r30
    eff6:	8a 30       	cpi	r24, 0x0A	; 10
    eff8:	89 f7       	brne	.-30     	; 0xefdc <sendRaw+0x16e>
    effa:	70 80       	ld	r7, Z
    effc:	10 82       	st	Z, r1
    effe:	8c e3       	ldi	r24, 0x3C	; 60
    f000:	0e 94 90 72 	call	0xe520	; 0xe520 <logTx>
    f004:	c4 01       	movw	r24, r8
    f006:	85 5b       	subi	r24, 0xB5	; 181
    f008:	99 4f       	sbci	r25, 0xF9	; 249
    f00a:	6c 01       	movw	r12, r24
    f00c:	0e 94 97 72 	call	0xe52e	; 0xe52e <logStrRaw>
    f010:	d1 30       	cpi	r29, 0x01	; 1
    f012:	81 f4       	brne	.+32     	; 0xf034 <sendRaw+0x1c6>
    f014:	c8 01       	movw	r24, r16
    f016:	88 19       	sub	r24, r8
    f018:	99 09       	sbc	r25, r9
    f01a:	03 97       	sbiw	r24, 0x03	; 3
    f01c:	e4 f4       	brge	.+56     	; 0xf056 <sendRaw+0x1e8>
    f01e:	f8 01       	movw	r30, r16
    f020:	e5 5b       	subi	r30, 0xB5	; 181
    f022:	f9 4f       	sbci	r31, 0xF9	; 249
    f024:	70 82       	st	Z, r7
    f026:	10 93 4e 0e 	sts	0x0E4E, r17	; 0x800e4e <httpBodyStart+0x1>
    f02a:	00 93 4d 0e 	sts	0x0E4D, r16	; 0x800e4d <httpBodyStart>
    f02e:	f6 01       	movw	r30, r12
    f030:	10 82       	st	Z, r1
    f032:	22 c0       	rjmp	.+68     	; 0xf078 <sendRaw+0x20a>
    f034:	d1 11       	cpse	r29, r1
    f036:	1c c0       	rjmp	.+56     	; 0xf070 <sendRaw+0x202>
    f038:	c8 01       	movw	r24, r16
    f03a:	88 19       	sub	r24, r8
    f03c:	99 09       	sbc	r25, r9
    f03e:	03 97       	sbiw	r24, 0x03	; 3
    f040:	bc f0       	brlt	.+46     	; 0xf070 <sendRaw+0x202>
    f042:	c6 01       	movw	r24, r12
    f044:	0e 94 e0 76 	call	0xedc0	; 0xedc0 <IsOK>
    f048:	81 11       	cpse	r24, r1
    f04a:	12 c0       	rjmp	.+36     	; 0xf070 <sendRaw+0x202>
    f04c:	c6 01       	movw	r24, r12
    f04e:	0e 94 04 77 	call	0xee08	; 0xee08 <IsConnect>
    f052:	81 11       	cpse	r24, r1
    f054:	0d c0       	rjmp	.+26     	; 0xf070 <sendRaw+0x202>
    f056:	a1 14       	cp	r10, r1
    f058:	b1 04       	cpc	r11, r1
    f05a:	51 f0       	breq	.+20     	; 0xf070 <sendRaw+0x202>
    f05c:	c6 01       	movw	r24, r12
    f05e:	f5 01       	movw	r30, r10
    f060:	09 95       	icall
    f062:	88 23       	and	r24, r24
    f064:	e9 f0       	breq	.+58     	; 0xf0a0 <sendRaw+0x232>
    f066:	80 e7       	ldi	r24, 0x70	; 112
    f068:	92 e0       	ldi	r25, 0x02	; 2
    f06a:	0e 94 a4 72 	call	0xe548	; 0xe548 <logStr>
    f06e:	cf 5f       	subi	r28, 0xFF	; 255
    f070:	f7 01       	movw	r30, r14
    f072:	70 82       	st	Z, r7
    f074:	48 01       	movw	r8, r16
    f076:	b2 cf       	rjmp	.-156    	; 0xefdc <sendRaw+0x16e>
    f078:	8c 2f       	mov	r24, r28
    f07a:	0c 2e       	mov	r0, r28
    f07c:	00 0c       	add	r0, r0
    f07e:	99 0b       	sbc	r25, r25
    f080:	9f 93       	push	r25
    f082:	cf 93       	push	r28
    f084:	86 e7       	ldi	r24, 0x76	; 118
    f086:	92 e0       	ldi	r25, 0x02	; 2
    f088:	9f 93       	push	r25
    f08a:	8f 93       	push	r24
    f08c:	0e 94 aa 72 	call	0xe554	; 0xe554 <logd>
    f090:	0f 90       	pop	r0
    f092:	0f 90       	pop	r0
    f094:	0f 90       	pop	r0
    f096:	0f 90       	pop	r0
    f098:	8c 2f       	mov	r24, r28
    f09a:	07 c0       	rjmp	.+14     	; 0xf0aa <sendRaw+0x23c>
    f09c:	8f ef       	ldi	r24, 0xFF	; 255
    f09e:	05 c0       	rjmp	.+10     	; 0xf0aa <sendRaw+0x23c>
    f0a0:	83 e7       	ldi	r24, 0x73	; 115
    f0a2:	92 e0       	ldi	r25, 0x02	; 2
    f0a4:	0e 94 a4 72 	call	0xe548	; 0xe548 <logStr>
    f0a8:	e3 cf       	rjmp	.-58     	; 0xf070 <sendRaw+0x202>
    f0aa:	df 91       	pop	r29
    f0ac:	cf 91       	pop	r28
    f0ae:	1f 91       	pop	r17
    f0b0:	0f 91       	pop	r16
    f0b2:	ff 90       	pop	r15
    f0b4:	ef 90       	pop	r14
    f0b6:	df 90       	pop	r13
    f0b8:	cf 90       	pop	r12
    f0ba:	bf 90       	pop	r11
    f0bc:	af 90       	pop	r10
    f0be:	9f 90       	pop	r9
    f0c0:	8f 90       	pop	r8
    f0c2:	7f 90       	pop	r7
    f0c4:	08 95       	ret

0000f0c6 <sendAT>:
    f0c6:	20 e0       	ldi	r18, 0x00	; 0
    f0c8:	0c 94 37 77 	jmp	0xee6e	; 0xee6e <sendRaw>

0000f0cc <sendAT1>:
    f0cc:	cf 93       	push	r28
    f0ce:	df 93       	push	r29
    f0d0:	cd b7       	in	r28, 0x3d	; 61
    f0d2:	de b7       	in	r29, 0x3e	; 62
    f0d4:	ae 01       	movw	r20, r28
    f0d6:	45 5f       	subi	r20, 0xF5	; 245
    f0d8:	5f 4f       	sbci	r21, 0xFF	; 255
    f0da:	6d 81       	ldd	r22, Y+5	; 0x05
    f0dc:	7e 81       	ldd	r23, Y+6	; 0x06
    f0de:	8b e4       	ldi	r24, 0x4B	; 75
    f0e0:	96 e0       	ldi	r25, 0x06	; 6
    f0e2:	0e 94 dd 71 	call	0xe3ba	; 0xe3ba <qprintfv>
    f0e6:	49 85       	ldd	r20, Y+9	; 0x09
    f0e8:	5a 85       	ldd	r21, Y+10	; 0x0a
    f0ea:	6f 81       	ldd	r22, Y+7	; 0x07
    f0ec:	78 85       	ldd	r23, Y+8	; 0x08
    f0ee:	8b e4       	ldi	r24, 0x4B	; 75
    f0f0:	96 e0       	ldi	r25, 0x06	; 6
    f0f2:	0e 94 63 78 	call	0xf0c6	; 0xf0c6 <sendAT>
    f0f6:	df 91       	pop	r29
    f0f8:	cf 91       	pop	r28
    f0fa:	08 95       	ret

0000f0fc <sendAT2>:
    f0fc:	ef 92       	push	r14
    f0fe:	ff 92       	push	r15
    f100:	0f 93       	push	r16
    f102:	1f 93       	push	r17
    f104:	cf 93       	push	r28
    f106:	df 93       	push	r29
    f108:	cd b7       	in	r28, 0x3d	; 61
    f10a:	de b7       	in	r29, 0x3e	; 62
    f10c:	e9 88       	ldd	r14, Y+17	; 0x11
    f10e:	fa 88       	ldd	r15, Y+18	; 0x12
    f110:	00 e0       	ldi	r16, 0x00	; 0
    f112:	10 e0       	ldi	r17, 0x00	; 0
    f114:	8d 85       	ldd	r24, Y+13	; 0x0d
    f116:	9e 85       	ldd	r25, Y+14	; 0x0e
    f118:	08 17       	cp	r16, r24
    f11a:	19 07       	cpc	r17, r25
    f11c:	34 f5       	brge	.+76     	; 0xf16a <sendAT2+0x6e>
    f11e:	ae 01       	movw	r20, r28
    f120:	4b 5e       	subi	r20, 0xEB	; 235
    f122:	5f 4f       	sbci	r21, 0xFF	; 255
    f124:	69 85       	ldd	r22, Y+9	; 0x09
    f126:	7a 85       	ldd	r23, Y+10	; 0x0a
    f128:	8b e4       	ldi	r24, 0x4B	; 75
    f12a:	96 e0       	ldi	r25, 0x06	; 6
    f12c:	0e 94 dd 71 	call	0xe3ba	; 0xe3ba <qprintfv>
    f130:	4b 89       	ldd	r20, Y+19	; 0x13
    f132:	5c 89       	ldd	r21, Y+20	; 0x14
    f134:	6b 85       	ldd	r22, Y+11	; 0x0b
    f136:	7c 85       	ldd	r23, Y+12	; 0x0c
    f138:	8b e4       	ldi	r24, 0x4B	; 75
    f13a:	96 e0       	ldi	r25, 0x06	; 6
    f13c:	0e 94 63 78 	call	0xf0c6	; 0xf0c6 <sendAT>
    f140:	94 e6       	ldi	r25, 0x64	; 100
    f142:	e9 16       	cp	r14, r25
    f144:	f1 04       	cpc	r15, r1
    f146:	19 f4       	brne	.+6      	; 0xf14e <sendAT2+0x52>
    f148:	18 16       	cp	r1, r24
    f14a:	44 f4       	brge	.+16     	; 0xf15c <sendAT2+0x60>
    f14c:	0f c0       	rjmp	.+30     	; 0xf16c <sendAT2+0x70>
    f14e:	28 2f       	mov	r18, r24
    f150:	08 2e       	mov	r0, r24
    f152:	00 0c       	add	r0, r0
    f154:	33 0b       	sbc	r19, r19
    f156:	e2 16       	cp	r14, r18
    f158:	f3 06       	cpc	r15, r19
    f15a:	41 f0       	breq	.+16     	; 0xf16c <sendAT2+0x70>
    f15c:	8f 85       	ldd	r24, Y+15	; 0x0f
    f15e:	98 89       	ldd	r25, Y+16	; 0x10
    f160:	0e 94 7b 70 	call	0xe0f6	; 0xe0f6 <delay_secs>
    f164:	0f 5f       	subi	r16, 0xFF	; 255
    f166:	1f 4f       	sbci	r17, 0xFF	; 255
    f168:	d5 cf       	rjmp	.-86     	; 0xf114 <sendAT2+0x18>
    f16a:	8f ef       	ldi	r24, 0xFF	; 255
    f16c:	df 91       	pop	r29
    f16e:	cf 91       	pop	r28
    f170:	1f 91       	pop	r17
    f172:	0f 91       	pop	r16
    f174:	ff 90       	pop	r15
    f176:	ef 90       	pop	r14
    f178:	08 95       	ret

0000f17a <sendHTTP>:
    f17a:	cf 93       	push	r28
    f17c:	df 93       	push	r29
    f17e:	cd b7       	in	r28, 0x3d	; 61
    f180:	de b7       	in	r29, 0x3e	; 62
    f182:	ae 01       	movw	r20, r28
    f184:	45 5f       	subi	r20, 0xF5	; 245
    f186:	5f 4f       	sbci	r21, 0xFF	; 255
    f188:	6d 81       	ldd	r22, Y+5	; 0x05
    f18a:	7e 81       	ldd	r23, Y+6	; 0x06
    f18c:	8b e4       	ldi	r24, 0x4B	; 75
    f18e:	96 e0       	ldi	r25, 0x06	; 6
    f190:	0e 94 dd 71 	call	0xe3ba	; 0xe3ba <qprintfv>
    f194:	21 e0       	ldi	r18, 0x01	; 1
    f196:	49 85       	ldd	r20, Y+9	; 0x09
    f198:	5a 85       	ldd	r21, Y+10	; 0x0a
    f19a:	6f 81       	ldd	r22, Y+7	; 0x07
    f19c:	78 85       	ldd	r23, Y+8	; 0x08
    f19e:	8b e4       	ldi	r24, 0x4B	; 75
    f1a0:	96 e0       	ldi	r25, 0x06	; 6
    f1a2:	0e 94 37 77 	call	0xee6e	; 0xee6e <sendRaw>
    f1a6:	df 91       	pop	r29
    f1a8:	cf 91       	pop	r28
    f1aa:	08 95       	ret

0000f1ac <sendOperatorSelection>:
    f1ac:	0f 93       	push	r16
    f1ae:	1f 93       	push	r17
    f1b0:	cf 93       	push	r28
    f1b2:	df 93       	push	r29
    f1b4:	cd b7       	in	r28, 0x3d	; 61
    f1b6:	de b7       	in	r29, 0x3e	; 62
    f1b8:	2a 97       	sbiw	r28, 0x0a	; 10
    f1ba:	0f b6       	in	r0, 0x3f	; 63
    f1bc:	f8 94       	cli
    f1be:	de bf       	out	0x3e, r29	; 62
    f1c0:	0f be       	out	0x3f, r0	; 63
    f1c2:	cd bf       	out	0x3d, r28	; 61
    f1c4:	80 91 7e 05 	lds	r24, 0x057E	; 0x80057e <appEepromData+0xf>
    f1c8:	81 30       	cpi	r24, 0x01	; 1
    f1ca:	f9 f4       	brne	.+62     	; 0xf20a <sendOperatorSelection+0x5e>
    f1cc:	1f 92       	push	r1
    f1ce:	84 e0       	ldi	r24, 0x04	; 4
    f1d0:	8f 93       	push	r24
    f1d2:	2f e7       	ldi	r18, 0x7F	; 127
    f1d4:	35 e0       	ldi	r19, 0x05	; 5
    f1d6:	3f 93       	push	r19
    f1d8:	2f 93       	push	r18
    f1da:	1f 92       	push	r1
    f1dc:	8f 93       	push	r24
    f1de:	84 e8       	ldi	r24, 0x84	; 132
    f1e0:	95 e0       	ldi	r25, 0x05	; 5
    f1e2:	9f 93       	push	r25
    f1e4:	8f 93       	push	r24
    f1e6:	81 ed       	ldi	r24, 0xD1	; 209
    f1e8:	92 e0       	ldi	r25, 0x02	; 2
    f1ea:	9f 93       	push	r25
    f1ec:	8f 93       	push	r24
    f1ee:	8e 01       	movw	r16, r28
    f1f0:	0f 5f       	subi	r16, 0xFF	; 255
    f1f2:	1f 4f       	sbci	r17, 0xFF	; 255
    f1f4:	1f 93       	push	r17
    f1f6:	0f 93       	push	r16
    f1f8:	0e 94 80 72 	call	0xe500	; 0xe500 <qprintf>
    f1fc:	0f b6       	in	r0, 0x3f	; 63
    f1fe:	f8 94       	cli
    f200:	de bf       	out	0x3e, r29	; 62
    f202:	0f be       	out	0x3f, r0	; 63
    f204:	cd bf       	out	0x3d, r28	; 61
    f206:	c8 01       	movw	r24, r16
    f208:	08 c0       	rjmp	.+16     	; 0xf21a <sendOperatorSelection+0x6e>
    f20a:	80 91 6b 05 	lds	r24, 0x056B	; 0x80056b <curOprt>
    f20e:	3c e0       	ldi	r19, 0x0C	; 12
    f210:	83 9f       	mul	r24, r19
    f212:	c0 01       	movw	r24, r0
    f214:	11 24       	eor	r1, r1
    f216:	8a 59       	subi	r24, 0x9A	; 154
    f218:	91 4f       	sbci	r25, 0xF1	; 241
    f21a:	9f 93       	push	r25
    f21c:	8f 93       	push	r24
    f21e:	1f 92       	push	r1
    f220:	1f 92       	push	r1
    f222:	1f 92       	push	r1
    f224:	82 e0       	ldi	r24, 0x02	; 2
    f226:	8f 93       	push	r24
    f228:	86 ed       	ldi	r24, 0xD6	; 214
    f22a:	92 e0       	ldi	r25, 0x02	; 2
    f22c:	9f 93       	push	r25
    f22e:	8f 93       	push	r24
    f230:	0e 94 66 78 	call	0xf0cc	; 0xf0cc <sendAT1>
    f234:	91 e0       	ldi	r25, 0x01	; 1
    f236:	0f b6       	in	r0, 0x3f	; 63
    f238:	f8 94       	cli
    f23a:	de bf       	out	0x3e, r29	; 62
    f23c:	0f be       	out	0x3f, r0	; 63
    f23e:	cd bf       	out	0x3d, r28	; 61
    f240:	81 11       	cpse	r24, r1
    f242:	90 e0       	ldi	r25, 0x00	; 0
    f244:	89 2f       	mov	r24, r25
    f246:	2a 96       	adiw	r28, 0x0a	; 10
    f248:	0f b6       	in	r0, 0x3f	; 63
    f24a:	f8 94       	cli
    f24c:	de bf       	out	0x3e, r29	; 62
    f24e:	0f be       	out	0x3f, r0	; 63
    f250:	cd bf       	out	0x3d, r28	; 61
    f252:	df 91       	pop	r29
    f254:	cf 91       	pop	r28
    f256:	1f 91       	pop	r17
    f258:	0f 91       	pop	r16
    f25a:	08 95       	ret

0000f25c <parseXREGResponse>:
    f25c:	cf 93       	push	r28
    f25e:	df 93       	push	r29
    f260:	00 d0       	rcall	.+0      	; 0xf262 <parseXREGResponse+0x6>
    f262:	cd b7       	in	r28, 0x3d	; 61
    f264:	de b7       	in	r29, 0x3e	; 62
    f266:	9e 01       	movw	r18, r28
    f268:	2f 5f       	subi	r18, 0xFF	; 255
    f26a:	3f 4f       	sbci	r19, 0xFF	; 255
    f26c:	3f 93       	push	r19
    f26e:	2f 93       	push	r18
    f270:	2f 5f       	subi	r18, 0xFF	; 255
    f272:	3f 4f       	sbci	r19, 0xFF	; 255
    f274:	3f 93       	push	r19
    f276:	2f 93       	push	r18
    f278:	7f 93       	push	r23
    f27a:	6f 93       	push	r22
    f27c:	9f 93       	push	r25
    f27e:	8f 93       	push	r24
    f280:	0e 94 3e 71 	call	0xe27c	; 0xe27c <qscanf>
    f284:	0f b6       	in	r0, 0x3f	; 63
    f286:	f8 94       	cli
    f288:	de bf       	out	0x3e, r29	; 62
    f28a:	0f be       	out	0x3f, r0	; 63
    f28c:	cd bf       	out	0x3d, r28	; 61
    f28e:	02 97       	sbiw	r24, 0x02	; 2
    f290:	29 f4       	brne	.+10     	; 0xf29c <parseXREGResponse+0x40>
    f292:	99 81       	ldd	r25, Y+1	; 0x01
    f294:	9b 7f       	andi	r25, 0xFB	; 251
    f296:	81 e0       	ldi	r24, 0x01	; 1
    f298:	91 30       	cpi	r25, 0x01	; 1
    f29a:	09 f0       	breq	.+2      	; 0xf29e <parseXREGResponse+0x42>
    f29c:	80 e0       	ldi	r24, 0x00	; 0
    f29e:	0f 90       	pop	r0
    f2a0:	0f 90       	pop	r0
    f2a2:	df 91       	pop	r29
    f2a4:	cf 91       	pop	r28
    f2a6:	08 95       	ret

0000f2a8 <parseCREGResponse>:
    f2a8:	69 ee       	ldi	r22, 0xE9	; 233
    f2aa:	72 e0       	ldi	r23, 0x02	; 2
    f2ac:	0c 94 2e 79 	jmp	0xf25c	; 0xf25c <parseXREGResponse>

0000f2b0 <parseCGREGResponse>:
    f2b0:	66 ef       	ldi	r22, 0xF6	; 246
    f2b2:	72 e0       	ldi	r23, 0x02	; 2
    f2b4:	0c 94 2e 79 	jmp	0xf25c	; 0xf25c <parseXREGResponse>

0000f2b8 <initModem>:

bool initModem()
{
    f2b8:	cf 93       	push	r28
    _logs("INIT");
    f2ba:	86 ee       	ldi	r24, 0xE6	; 230
    f2bc:	91 e0       	ldi	r25, 0x01	; 1
    f2be:	0e 94 a4 72 	call	0xe548	; 0xe548 <logStr>

	rssi_val = 0;
    f2c2:	10 92 e2 0e 	sts	0x0EE2, r1	; 0x800ee2 <rssi_val>
    {
        return false;
    }
*/
	// skip other initialization on modem init and assume it is initialized
	if (shortModemInit)
    f2c6:	c0 91 00 01 	lds	r28, 0x0100	; 0x800100 <__data_start>
    f2ca:	c1 11       	cpse	r28, r1
    f2cc:	49 c0       	rjmp	.+146    	; 0xf360 <initModem+0xa8>
	{
		return true;
	}

    // detect cellular operator automatically
    if (sendAT("AT+COPS=0\r\n", 3, NULL) < 0)
    f2ce:	40 e0       	ldi	r20, 0x00	; 0
    f2d0:	50 e0       	ldi	r21, 0x00	; 0
    f2d2:	63 e0       	ldi	r22, 0x03	; 3
    f2d4:	70 e0       	ldi	r23, 0x00	; 0
    f2d6:	80 e2       	ldi	r24, 0x20	; 32
    f2d8:	93 e0       	ldi	r25, 0x03	; 3
    f2da:	0e 94 63 78 	call	0xf0c6	; 0xf0c6 <sendAT>
    f2de:	87 fd       	sbrc	r24, 7
    f2e0:	40 c0       	rjmp	.+128    	; 0xf362 <initModem+0xaa>
    {
        return false;
    }

	// for general GSM modem always go to roaming
    isRoaming = (appEepromData.eUseCntrCode == 0) && !isVerizonConnection();
    f2e2:	90 91 7e 05 	lds	r25, 0x057E	; 0x80057e <appEepromData+0xf>
    f2e6:	91 11       	cpse	r25, r1
    f2e8:	05 c0       	rjmp	.+10     	; 0xf2f4 <initModem+0x3c>
    f2ea:	81 e0       	ldi	r24, 0x01	; 1
    f2ec:	20 91 6a 05 	lds	r18, 0x056A	; 0x80056a <__data_end>
    f2f0:	21 30       	cpi	r18, 0x01	; 1
    f2f2:	09 f4       	brne	.+2      	; 0xf2f6 <initModem+0x3e>
    f2f4:	80 e0       	ldi	r24, 0x00	; 0
    f2f6:	80 93 e3 0e 	sts	0x0EE3, r24	; 0x800ee3 <isRoaming>

	curOprt = 0;
    f2fa:	10 92 6b 05 	sts	0x056B, r1	; 0x80056b <curOprt>
	numOprt = 0;
    f2fe:	10 92 6c 05 	sts	0x056C, r1	; 0x80056c <numOprt>

    if (appEepromData.eUseCntrCode == 0 && isRoaming)
    f302:	99 23       	and	r25, r25
    f304:	29 f0       	breq	.+10     	; 0xf310 <initModem+0x58>
		{
			return false;
		}
    }

    _logs("INIT OK");
    f306:	8c e2       	ldi	r24, 0x2C	; 44
    f308:	93 e0       	ldi	r25, 0x03	; 3
    f30a:	0e 94 a4 72 	call	0xe548	; 0xe548 <logStr>
    f30e:	28 c0       	rjmp	.+80     	; 0xf360 <initModem+0xa8>
    isRoaming = (appEepromData.eUseCntrCode == 0) && !isVerizonConnection();

	curOprt = 0;
	numOprt = 0;

    if (appEepromData.eUseCntrCode == 0 && isRoaming)
    f310:	88 23       	and	r24, r24
    f312:	c9 f3       	breq	.-14     	; 0xf306 <initModem+0x4e>
    {
		//SUB_TASK_INIT_MODEM_COPS_LST

		// get operators
		if (sendAT2("AT+COPS=?\r\n", 90, 15, 10, CONDITION_GT0, parseCOPSResponse) <= 0)
    f314:	81 e0       	ldi	r24, 0x01	; 1
    f316:	96 e7       	ldi	r25, 0x76	; 118
    f318:	9f 93       	push	r25
    f31a:	8f 93       	push	r24
    f31c:	1f 92       	push	r1
    f31e:	84 e6       	ldi	r24, 0x64	; 100
    f320:	8f 93       	push	r24
    f322:	1f 92       	push	r1
    f324:	8a e0       	ldi	r24, 0x0A	; 10
    f326:	8f 93       	push	r24
    f328:	1f 92       	push	r1
    f32a:	8f e0       	ldi	r24, 0x0F	; 15
    f32c:	8f 93       	push	r24
    f32e:	1f 92       	push	r1
    f330:	8a e5       	ldi	r24, 0x5A	; 90
    f332:	8f 93       	push	r24
    f334:	84 e3       	ldi	r24, 0x34	; 52
    f336:	93 e0       	ldi	r25, 0x03	; 3
    f338:	9f 93       	push	r25
    f33a:	8f 93       	push	r24
    f33c:	0e 94 7e 78 	call	0xf0fc	; 0xf0fc <sendAT2>
    f340:	2d b7       	in	r18, 0x3d	; 61
    f342:	3e b7       	in	r19, 0x3e	; 62
    f344:	24 5f       	subi	r18, 0xF4	; 244
    f346:	3f 4f       	sbci	r19, 0xFF	; 255
    f348:	0f b6       	in	r0, 0x3f	; 63
    f34a:	f8 94       	cli
    f34c:	3e bf       	out	0x3e, r19	; 62
    f34e:	0f be       	out	0x3f, r0	; 63
    f350:	2d bf       	out	0x3d, r18	; 61
    f352:	18 16       	cp	r1, r24
    f354:	34 f4       	brge	.+12     	; 0xf362 <initModem+0xaa>
		{
			return false;
		}
		    
		// no operators found
		if (numOprt == 0)
    f356:	80 91 6c 05 	lds	r24, 0x056C	; 0x80056c <numOprt>
    f35a:	81 11       	cpse	r24, r1
    f35c:	d4 cf       	rjmp	.-88     	; 0xf306 <initModem+0x4e>
    f35e:	01 c0       	rjmp	.+2      	; 0xf362 <initModem+0xaa>
    }
*/
	// skip other initialization on modem init and assume it is initialized
	if (shortModemInit)
	{
		return true;
    f360:	c1 e0       	ldi	r28, 0x01	; 1
		}
    }

    _logs("INIT OK");
	return true;
}
    f362:	8c 2f       	mov	r24, r28
    f364:	cf 91       	pop	r28
    f366:	08 95       	ret

0000f368 <modemRegisterNextOperator>:

	return false;
}

bool modemRegisterNextOperator()
{    
    f368:	df 92       	push	r13
    f36a:	ef 92       	push	r14
    f36c:	ff 92       	push	r15
    f36e:	0f 93       	push	r16
    f370:	1f 93       	push	r17
    f372:	cf 93       	push	r28
    f374:	df 93       	push	r29
	// skip initialization that could be already performed
	if (!shortModemInit)
    f376:	80 91 00 01 	lds	r24, 0x0100	; 0x800100 <__data_start>
    f37a:	81 11       	cpse	r24, r1
    f37c:	05 c1       	rjmp	.+522    	; 0xf588 <modemRegisterNextOperator+0x220>
	{
		sbyte regstatus = -1;

		if (isRoaming)
    f37e:	80 91 e3 0e 	lds	r24, 0x0EE3	; 0x800ee3 <isRoaming>
    f382:	81 11       	cpse	r24, r1
    f384:	28 c0       	rjmp	.+80     	; 0xf3d6 <modemRegisterNextOperator+0x6e>
				return false;
			}
		}

		// perform registration
		delay_secs(10);
    f386:	8a e0       	ldi	r24, 0x0A	; 10
    f388:	90 e0       	ldi	r25, 0x00	; 0
    f38a:	0e 94 7b 70 	call	0xe0f6	; 0xe0f6 <delay_secs>

		if (!isVerizonConnection())
    f38e:	80 91 6a 05 	lds	r24, 0x056A	; 0x80056a <__data_end>
    f392:	81 30       	cpi	r24, 0x01	; 1
    f394:	89 f1       	breq	.+98     	; 0xf3f8 <modemRegisterNextOperator+0x90>
		{
			//SUB_TASK_INIT_MODEM_REG
			sendAT2("AT+CREG?\r\n", 3, 30, 4, 1, parseCREGResponse);
    f396:	84 e5       	ldi	r24, 0x54	; 84
    f398:	99 e7       	ldi	r25, 0x79	; 121
    f39a:	9f 93       	push	r25
    f39c:	8f 93       	push	r24
    f39e:	1f 92       	push	r1
    f3a0:	81 e0       	ldi	r24, 0x01	; 1
    f3a2:	8f 93       	push	r24
    f3a4:	1f 92       	push	r1
    f3a6:	84 e0       	ldi	r24, 0x04	; 4
    f3a8:	8f 93       	push	r24
    f3aa:	1f 92       	push	r1
    f3ac:	8e e1       	ldi	r24, 0x1E	; 30
    f3ae:	8f 93       	push	r24
    f3b0:	1f 92       	push	r1
    f3b2:	83 e0       	ldi	r24, 0x03	; 3
    f3b4:	8f 93       	push	r24
    f3b6:	80 e4       	ldi	r24, 0x40	; 64
    f3b8:	93 e0       	ldi	r25, 0x03	; 3
    f3ba:	9f 93       	push	r25
    f3bc:	8f 93       	push	r24
    f3be:	0e 94 7e 78 	call	0xf0fc	; 0xf0fc <sendAT2>
    f3c2:	2d b7       	in	r18, 0x3d	; 61
    f3c4:	3e b7       	in	r19, 0x3e	; 62
    f3c6:	24 5f       	subi	r18, 0xF4	; 244
    f3c8:	3f 4f       	sbci	r19, 0xFF	; 255
    f3ca:	0f b6       	in	r0, 0x3f	; 63
    f3cc:	f8 94       	cli
    f3ce:	3e bf       	out	0x3e, r19	; 62
    f3d0:	0f be       	out	0x3f, r0	; 63
    f3d2:	2d bf       	out	0x3d, r18	; 61
    f3d4:	11 c0       	rjmp	.+34     	; 0xf3f8 <modemRegisterNextOperator+0x90>
	{
		sbyte regstatus = -1;

		if (isRoaming)
		{
			if (curOprt >= numOprt && !appEepromData.eUseCntrCode)
    f3d6:	90 91 6b 05 	lds	r25, 0x056B	; 0x80056b <curOprt>
    f3da:	80 91 6c 05 	lds	r24, 0x056C	; 0x80056c <numOprt>
    f3de:	98 17       	cp	r25, r24
    f3e0:	30 f0       	brcs	.+12     	; 0xf3ee <modemRegisterNextOperator+0x86>
    f3e2:	80 91 7e 05 	lds	r24, 0x057E	; 0x80057e <appEepromData+0xf>
    f3e6:	81 11       	cpse	r24, r1
    f3e8:	02 c0       	rjmp	.+4      	; 0xf3ee <modemRegisterNextOperator+0x86>
			{
				return false;
    f3ea:	80 e0       	ldi	r24, 0x00	; 0
    f3ec:	fa c0       	rjmp	.+500    	; 0xf5e2 <modemRegisterNextOperator+0x27a>
			}
	
			// try to select the operator
			if (!sendOperatorSelection())
    f3ee:	0e 94 d6 78 	call	0xf1ac	; 0xf1ac <sendOperatorSelection>
    f3f2:	81 11       	cpse	r24, r1
    f3f4:	c8 cf       	rjmp	.-112    	; 0xf386 <modemRegisterNextOperator+0x1e>
    f3f6:	f9 cf       	rjmp	.-14     	; 0xf3ea <modemRegisterNextOperator+0x82>
		}
        
		// validate GPRS registration status

		//SUB_TASK_INIT_MODEM_REG_STAT
		regstatus = sendAT2("AT+CGREG?\r\n", 3, 15, 4, 1, parseCGREGResponse);
    f3f8:	88 e5       	ldi	r24, 0x58	; 88
    f3fa:	99 e7       	ldi	r25, 0x79	; 121
    f3fc:	9f 93       	push	r25
    f3fe:	8f 93       	push	r24
    f400:	1f 92       	push	r1
    f402:	81 e0       	ldi	r24, 0x01	; 1
    f404:	8f 93       	push	r24
    f406:	1f 92       	push	r1
    f408:	84 e0       	ldi	r24, 0x04	; 4
    f40a:	8f 93       	push	r24
    f40c:	1f 92       	push	r1
    f40e:	8f e0       	ldi	r24, 0x0F	; 15
    f410:	8f 93       	push	r24
    f412:	1f 92       	push	r1
    f414:	83 e0       	ldi	r24, 0x03	; 3
    f416:	8f 93       	push	r24
    f418:	8b e4       	ldi	r24, 0x4B	; 75
    f41a:	93 e0       	ldi	r25, 0x03	; 3
    f41c:	9f 93       	push	r25
    f41e:	8f 93       	push	r24
    f420:	0e 94 7e 78 	call	0xf0fc	; 0xf0fc <sendAT2>
        
		if (regstatus != 1)
    f424:	2d b7       	in	r18, 0x3d	; 61
    f426:	3e b7       	in	r19, 0x3e	; 62
    f428:	24 5f       	subi	r18, 0xF4	; 244
    f42a:	3f 4f       	sbci	r19, 0xFF	; 255
    f42c:	0f b6       	in	r0, 0x3f	; 63
    f42e:	f8 94       	cli
    f430:	3e bf       	out	0x3e, r19	; 62
    f432:	0f be       	out	0x3f, r0	; 63
    f434:	2d bf       	out	0x3d, r18	; 61
    f436:	81 30       	cpi	r24, 0x01	; 1
    f438:	c1 f6       	brne	.-80     	; 0xf3ea <modemRegisterNextOperator+0x82>
				//return false;
			//}
		//}
    
		// SUB_TASK_INIT_MODEM_GET_COPS
		if (sendAT("AT+COPS?\r\n", 3, NULL) < 0)
    f43a:	40 e0       	ldi	r20, 0x00	; 0
    f43c:	50 e0       	ldi	r21, 0x00	; 0
    f43e:	63 e0       	ldi	r22, 0x03	; 3
    f440:	70 e0       	ldi	r23, 0x00	; 0
    f442:	87 e5       	ldi	r24, 0x57	; 87
    f444:	93 e0       	ldi	r25, 0x03	; 3
    f446:	0e 94 63 78 	call	0xf0c6	; 0xf0c6 <sendAT>
    f44a:	87 fd       	sbrc	r24, 7
    f44c:	ce cf       	rjmp	.-100    	; 0xf3ea <modemRegisterNextOperator+0x82>
			return false;
		}
    
		// SUB_TASK_INIT_MODEM_MONITOR
		//if (sendAT("AT#MONI\r\n", 3, parseMONIResponse) != 1)
		if (sendAT("AT+QNWINFO\r\n", 3, parseMONIResponse)!= 1)
    f44e:	4d e8       	ldi	r20, 0x8D	; 141
    f450:	55 e7       	ldi	r21, 0x75	; 117
    f452:	63 e0       	ldi	r22, 0x03	; 3
    f454:	70 e0       	ldi	r23, 0x00	; 0
    f456:	82 e6       	ldi	r24, 0x62	; 98
    f458:	93 e0       	ldi	r25, 0x03	; 3
    f45a:	0e 94 63 78 	call	0xf0c6	; 0xf0c6 <sendAT>
    f45e:	81 30       	cpi	r24, 0x01	; 1
    f460:	21 f6       	brne	.-120    	; 0xf3ea <modemRegisterNextOperator+0x82>
		{
			return false;
		}

		// SUB_TASK_INIT_MODEM_RSSI
		if (sendAT("AT+CSQ\r\n", 3, parseCSQResponse) != 1)
    f462:	49 ed       	ldi	r20, 0xD9	; 217
    f464:	55 e7       	ldi	r21, 0x75	; 117
    f466:	63 e0       	ldi	r22, 0x03	; 3
    f468:	70 e0       	ldi	r23, 0x00	; 0
    f46a:	8f e6       	ldi	r24, 0x6F	; 111
    f46c:	93 e0       	ldi	r25, 0x03	; 3
    f46e:	0e 94 63 78 	call	0xf0c6	; 0xf0c6 <sendAT>
    f472:	81 30       	cpi	r24, 0x01	; 1
    f474:	09 f0       	breq	.+2      	; 0xf478 <modemRegisterNextOperator+0x110>
    f476:	b9 cf       	rjmp	.-142    	; 0xf3ea <modemRegisterNextOperator+0x82>
		{
			return false;
		}

		// stop connection is RSSI is too low
		if (rssi_val < 12)
    f478:	90 91 e2 0e 	lds	r25, 0x0EE2	; 0x800ee2 <rssi_val>
    f47c:	9c 30       	cpi	r25, 0x0C	; 12
    f47e:	08 f4       	brcc	.+2      	; 0xf482 <modemRegisterNextOperator+0x11a>
    f480:	b4 cf       	rjmp	.-152    	; 0xf3ea <modemRegisterNextOperator+0x82>
		{
			return false;
		}

		if (!isVerizonConnection())
    f482:	90 91 6a 05 	lds	r25, 0x056A	; 0x80056a <__data_end>
    f486:	91 30       	cpi	r25, 0x01	; 1
    f488:	31 f4       	brne	.+12     	; 0xf496 <modemRegisterNextOperator+0x12e>
	return true;
}

static bool SendPDPCntDef()
{
	socket = isVerizonConnection() ? 3 : 1;
    f48a:	80 91 6a 05 	lds	r24, 0x056A	; 0x80056a <__data_end>
    f48e:	81 30       	cpi	r24, 0x01	; 1
    f490:	f9 f0       	breq	.+62     	; 0xf4d0 <modemRegisterNextOperator+0x168>
    f492:	81 e0       	ldi	r24, 0x01	; 1
    f494:	1e c0       	rjmp	.+60     	; 0xf4d2 <modemRegisterNextOperator+0x16a>
		}

		if (!isVerizonConnection())
		{
			// SUB_TASK_MODEM_CONNECT_ATCH
			if (sendAT2("AT+CGATT=1\r\n", 2, 2, 1, 0, NULL) < 0)
    f496:	1f 92       	push	r1
    f498:	1f 92       	push	r1
    f49a:	1f 92       	push	r1
    f49c:	1f 92       	push	r1
    f49e:	1f 92       	push	r1
    f4a0:	8f 93       	push	r24
    f4a2:	1f 92       	push	r1
    f4a4:	82 e0       	ldi	r24, 0x02	; 2
    f4a6:	8f 93       	push	r24
    f4a8:	1f 92       	push	r1
    f4aa:	8f 93       	push	r24
    f4ac:	88 e7       	ldi	r24, 0x78	; 120
    f4ae:	93 e0       	ldi	r25, 0x03	; 3
    f4b0:	9f 93       	push	r25
    f4b2:	8f 93       	push	r24
    f4b4:	0e 94 7e 78 	call	0xf0fc	; 0xf0fc <sendAT2>
    f4b8:	2d b7       	in	r18, 0x3d	; 61
    f4ba:	3e b7       	in	r19, 0x3e	; 62
    f4bc:	24 5f       	subi	r18, 0xF4	; 244
    f4be:	3f 4f       	sbci	r19, 0xFF	; 255
    f4c0:	0f b6       	in	r0, 0x3f	; 63
    f4c2:	f8 94       	cli
    f4c4:	3e bf       	out	0x3e, r19	; 62
    f4c6:	0f be       	out	0x3f, r0	; 63
    f4c8:	2d bf       	out	0x3d, r18	; 61
    f4ca:	87 ff       	sbrs	r24, 7
    f4cc:	de cf       	rjmp	.-68     	; 0xf48a <modemRegisterNextOperator+0x122>
    f4ce:	8d cf       	rjmp	.-230    	; 0xf3ea <modemRegisterNextOperator+0x82>
	return true;
}

static bool SendPDPCntDef()
{
	socket = isVerizonConnection() ? 3 : 1;
    f4d0:	83 e0       	ldi	r24, 0x03	; 3
    f4d2:	80 93 01 01 	sts	0x0101, r24	; 0x800101 <socket>

	return sendAT1("AT+CGDCONT=%b,\"IP\",\"%#\"\r\n", 2, NULL, socket, appEepromData.eAPN, sizeof(appEepromData.eAPN) - 1) == 0;
    f4d6:	1f 92       	push	r1
    f4d8:	90 e2       	ldi	r25, 0x20	; 32
    f4da:	9f 93       	push	r25
    f4dc:	2f ea       	ldi	r18, 0xAF	; 175
    f4de:	35 e0       	ldi	r19, 0x05	; 5
    f4e0:	3f 93       	push	r19
    f4e2:	2f 93       	push	r18
    f4e4:	1f 92       	push	r1
    f4e6:	8f 93       	push	r24
    f4e8:	1f 92       	push	r1
    f4ea:	1f 92       	push	r1
    f4ec:	1f 92       	push	r1
    f4ee:	82 e0       	ldi	r24, 0x02	; 2
    f4f0:	8f 93       	push	r24
    f4f2:	85 e8       	ldi	r24, 0x85	; 133
    f4f4:	93 e0       	ldi	r25, 0x03	; 3
    f4f6:	9f 93       	push	r25
    f4f8:	8f 93       	push	r24
    f4fa:	0e 94 66 78 	call	0xf0cc	; 0xf0cc <sendAT1>
				return false;
			}
		}

		// SUB_TASK_MODEM_CONNECT_PDP_DEF
		if (!SendPDPCntDef()) 
    f4fe:	2d b7       	in	r18, 0x3d	; 61
    f500:	3e b7       	in	r19, 0x3e	; 62
    f502:	24 5f       	subi	r18, 0xF4	; 244
    f504:	3f 4f       	sbci	r19, 0xFF	; 255
    f506:	0f b6       	in	r0, 0x3f	; 63
    f508:	f8 94       	cli
    f50a:	3e bf       	out	0x3e, r19	; 62
    f50c:	0f be       	out	0x3f, r0	; 63
    f50e:	2d bf       	out	0x3d, r18	; 61
    f510:	81 11       	cpse	r24, r1
    f512:	6b cf       	rjmp	.-298    	; 0xf3ea <modemRegisterNextOperator+0x82>
		//{
			//return false;
		//}

		// deactivate previous PDP context (this releases stuck PDP context)
		sendAT1("AT+CGACT=%b,0\r\n", 10, NULL, socket);
    f514:	80 91 01 01 	lds	r24, 0x0101	; 0x800101 <socket>
    f518:	1f 92       	push	r1
    f51a:	8f 93       	push	r24
    f51c:	1f 92       	push	r1
    f51e:	1f 92       	push	r1
    f520:	1f 92       	push	r1
    f522:	ca e0       	ldi	r28, 0x0A	; 10
    f524:	cf 93       	push	r28
    f526:	8f e9       	ldi	r24, 0x9F	; 159
    f528:	93 e0       	ldi	r25, 0x03	; 3
    f52a:	9f 93       	push	r25
    f52c:	8f 93       	push	r24
    f52e:	0e 94 66 78 	call	0xf0cc	; 0xf0cc <sendAT1>

		// SUB_TASK_MODEM_CONNECT_ACTV
		if (sendAT2("AT+CGACT=%b,1\r\n", 10, 10, 1, 0, NULL, socket) < 0)
    f532:	80 91 01 01 	lds	r24, 0x0101	; 0x800101 <socket>
    f536:	1f 92       	push	r1
    f538:	8f 93       	push	r24
    f53a:	1f 92       	push	r1
    f53c:	1f 92       	push	r1
    f53e:	1f 92       	push	r1
    f540:	1f 92       	push	r1
    f542:	1f 92       	push	r1
    f544:	81 e0       	ldi	r24, 0x01	; 1
    f546:	8f 93       	push	r24
    f548:	1f 92       	push	r1
    f54a:	cf 93       	push	r28
    f54c:	1f 92       	push	r1
    f54e:	cf 93       	push	r28
    f550:	8f ea       	ldi	r24, 0xAF	; 175
    f552:	93 e0       	ldi	r25, 0x03	; 3
    f554:	9f 93       	push	r25
    f556:	8f 93       	push	r24
    f558:	0e 94 7e 78 	call	0xf0fc	; 0xf0fc <sendAT2>
    f55c:	2d b7       	in	r18, 0x3d	; 61
    f55e:	3e b7       	in	r19, 0x3e	; 62
    f560:	2a 5e       	subi	r18, 0xEA	; 234
    f562:	3f 4f       	sbci	r19, 0xFF	; 255
    f564:	0f b6       	in	r0, 0x3f	; 63
    f566:	f8 94       	cli
    f568:	3e bf       	out	0x3e, r19	; 62
    f56a:	0f be       	out	0x3f, r0	; 63
    f56c:	2d bf       	out	0x3d, r18	; 61
    f56e:	87 fd       	sbrc	r24, 7
    f570:	3c cf       	rjmp	.-392    	; 0xf3ea <modemRegisterNextOperator+0x82>
	return true;
}

static bool SendPDPCntDef()
{
	socket = isVerizonConnection() ? 3 : 1;
    f572:	c4 e0       	ldi	r28, 0x04	; 4
    f574:	d0 e0       	ldi	r29, 0x00	; 0
	int retry;

	for (retry = 0; retry <= 3; retry++)
	{
		//if (sendAT1("AT#SD=%b,0,80,\"%s\"\r\n", 120, NULL, socket, FIRMWARE_HOST_URL) >= 0)
		if (sendAT1("AT+QIOPEN=1,0,\"TCP\",\"%s\",80,0,2\r\n", 40, NULL ,FIRMWARE_HOST_URL) >= 0)
    f576:	0f eb       	ldi	r16, 0xBF	; 191
    f578:	13 e0       	ldi	r17, 0x03	; 3
    f57a:	88 e2       	ldi	r24, 0x28	; 40
    f57c:	d8 2e       	mov	r13, r24
    f57e:	96 ed       	ldi	r25, 0xD6	; 214
    f580:	e9 2e       	mov	r14, r25
    f582:	93 e0       	ldi	r25, 0x03	; 3
    f584:	f9 2e       	mov	r15, r25
    f586:	17 c0       	rjmp	.+46     	; 0xf5b6 <modemRegisterNextOperator+0x24e>
		}
	}
	else
	{
		// SUB_TASK_INIT_MODEM_RSSI
		if (sendAT("AT+CSQ\r\n", 3, parseCSQResponse) != 1)
    f588:	49 ed       	ldi	r20, 0xD9	; 217
    f58a:	55 e7       	ldi	r21, 0x75	; 117
    f58c:	63 e0       	ldi	r22, 0x03	; 3
    f58e:	70 e0       	ldi	r23, 0x00	; 0
    f590:	8f e6       	ldi	r24, 0x6F	; 111
    f592:	93 e0       	ldi	r25, 0x03	; 3
    f594:	0e 94 63 78 	call	0xf0c6	; 0xf0c6 <sendAT>
    f598:	81 30       	cpi	r24, 0x01	; 1
    f59a:	09 f0       	breq	.+2      	; 0xf59e <modemRegisterNextOperator+0x236>
    f59c:	26 cf       	rjmp	.-436    	; 0xf3ea <modemRegisterNextOperator+0x82>
		{
			return false;
		}

		// stop connection is RSSI is too low
		if (rssi_val < 10)
    f59e:	80 91 e2 0e 	lds	r24, 0x0EE2	; 0x800ee2 <rssi_val>
    f5a2:	8a 30       	cpi	r24, 0x0A	; 10
    f5a4:	30 f7       	brcc	.-52     	; 0xf572 <modemRegisterNextOperator+0x20a>
    f5a6:	21 cf       	rjmp	.-446    	; 0xf3ea <modemRegisterNextOperator+0x82>
		if (sendAT1("AT+QIOPEN=1,0,\"TCP\",\"%s\",80,0,2\r\n", 40, NULL ,FIRMWARE_HOST_URL) >= 0)
		{
			return true;
		}

		delay_secs(1);
    f5a8:	81 e0       	ldi	r24, 0x01	; 1
    f5aa:	90 e0       	ldi	r25, 0x00	; 0
    f5ac:	0e 94 7b 70 	call	0xe0f6	; 0xe0f6 <delay_secs>
    f5b0:	21 97       	sbiw	r28, 0x01	; 1

static bool SendStartDial()
{
	int retry;

	for (retry = 0; retry <= 3; retry++)
    f5b2:	09 f4       	brne	.+2      	; 0xf5b6 <modemRegisterNextOperator+0x24e>
    f5b4:	1a cf       	rjmp	.-460    	; 0xf3ea <modemRegisterNextOperator+0x82>
	{
		//if (sendAT1("AT#SD=%b,0,80,\"%s\"\r\n", 120, NULL, socket, FIRMWARE_HOST_URL) >= 0)
		if (sendAT1("AT+QIOPEN=1,0,\"TCP\",\"%s\",80,0,2\r\n", 40, NULL ,FIRMWARE_HOST_URL) >= 0)
    f5b6:	1f 93       	push	r17
    f5b8:	0f 93       	push	r16
    f5ba:	1f 92       	push	r1
    f5bc:	1f 92       	push	r1
    f5be:	1f 92       	push	r1
    f5c0:	df 92       	push	r13
    f5c2:	ff 92       	push	r15
    f5c4:	ef 92       	push	r14
    f5c6:	0e 94 66 78 	call	0xf0cc	; 0xf0cc <sendAT1>
    f5ca:	2d b7       	in	r18, 0x3d	; 61
    f5cc:	3e b7       	in	r19, 0x3e	; 62
    f5ce:	28 5f       	subi	r18, 0xF8	; 248
    f5d0:	3f 4f       	sbci	r19, 0xFF	; 255
    f5d2:	0f b6       	in	r0, 0x3f	; 63
    f5d4:	f8 94       	cli
    f5d6:	3e bf       	out	0x3e, r19	; 62
    f5d8:	0f be       	out	0x3f, r0	; 63
    f5da:	2d bf       	out	0x3d, r18	; 61
    f5dc:	87 fd       	sbrc	r24, 7
    f5de:	e4 cf       	rjmp	.-56     	; 0xf5a8 <modemRegisterNextOperator+0x240>
	if (!SendStartDial())
	{
		return false;
	}

    return true;
    f5e0:	81 e0       	ldi	r24, 0x01	; 1
}
    f5e2:	df 91       	pop	r29
    f5e4:	cf 91       	pop	r28
    f5e6:	1f 91       	pop	r17
    f5e8:	0f 91       	pop	r16
    f5ea:	ff 90       	pop	r15
    f5ec:	ef 90       	pop	r14
    f5ee:	df 90       	pop	r13
    f5f0:	08 95       	ret

0000f5f2 <connectModem>:

bool connectModem(bool cycleOperators)
{
    f5f2:	cf 93       	push	r28
    f5f4:	c8 2f       	mov	r28, r24
	_logs("CONNECT");
    f5f6:	88 ef       	ldi	r24, 0xF8	; 248
    f5f8:	93 e0       	ldi	r25, 0x03	; 3
    f5fa:	0e 94 a4 72 	call	0xe548	; 0xe548 <logStr>

	// we always start from the first operator
	curOprt = 0;
    f5fe:	10 92 6b 05 	sts	0x056B, r1	; 0x80056b <curOprt>

	while (true)
	{
		if (modemRegisterNextOperator())
    f602:	0e 94 b4 79 	call	0xf368	; 0xf368 <modemRegisterNextOperator>
    f606:	81 11       	cpse	r24, r1
    f608:	18 c0       	rjmp	.+48     	; 0xf63a <connectModem+0x48>
		{
			break;
		}

		if (!cycleOperators || shortModemInit)
    f60a:	cc 23       	and	r28, r28
    f60c:	d9 f0       	breq	.+54     	; 0xf644 <connectModem+0x52>
    f60e:	90 91 00 01 	lds	r25, 0x0100	; 0x800100 <__data_start>
    f612:	91 11       	cpse	r25, r1
    f614:	17 c0       	rjmp	.+46     	; 0xf644 <connectModem+0x52>
		{
			return false;
		}

		if (curOprt >= numOprt || appEepromData.eUseCntrCode || !isRoaming)
    f616:	90 91 6b 05 	lds	r25, 0x056B	; 0x80056b <curOprt>
    f61a:	20 91 6c 05 	lds	r18, 0x056C	; 0x80056c <numOprt>
    f61e:	92 17       	cp	r25, r18
    f620:	88 f4       	brcc	.+34     	; 0xf644 <connectModem+0x52>
    f622:	20 91 7e 05 	lds	r18, 0x057E	; 0x80057e <appEepromData+0xf>
    f626:	21 11       	cpse	r18, r1
    f628:	0d c0       	rjmp	.+26     	; 0xf644 <connectModem+0x52>
    f62a:	80 91 e3 0e 	lds	r24, 0x0EE3	; 0x800ee3 <isRoaming>
    f62e:	88 23       	and	r24, r24
    f630:	49 f0       	breq	.+18     	; 0xf644 <connectModem+0x52>
		{
			return false;
		}
	
		curOprt++;
    f632:	9f 5f       	subi	r25, 0xFF	; 255
    f634:	90 93 6b 05 	sts	0x056B, r25	; 0x80056b <curOprt>
	}
    f638:	e4 cf       	rjmp	.-56     	; 0xf602 <connectModem+0x10>

	_logs("CONNECT OK");
    f63a:	80 e0       	ldi	r24, 0x00	; 0
    f63c:	94 e0       	ldi	r25, 0x04	; 4
    f63e:	0e 94 a4 72 	call	0xe548	; 0xe548 <logStr>
	return true;
    f642:	81 e0       	ldi	r24, 0x01	; 1
}
    f644:	cf 91       	pop	r28
    f646:	08 95       	ret

0000f648 <closeModem>:

bool closeModem()
{
    f648:	cf 93       	push	r28
	byte retry = 0;

	if (!isModemOn())
    f64a:	0e 94 d9 76 	call	0xedb2	; 0xedb2 <isModemOn>
    f64e:	88 23       	and	r24, r24
    f650:	99 f1       	breq	.+102    	; 0xf6b8 <closeModem+0x70>
	{
		return true;
	}

	_logs("CLOSE");
    f652:	8b e0       	ldi	r24, 0x0B	; 11
    f654:	94 e0       	ldi	r25, 0x04	; 4
    f656:	0e 94 a4 72 	call	0xe548	; 0xe548 <logStr>

	// try to close data stream if it is opened
	// SUB_TASK_MODEM_CLOSE_EOD
	sendAT("+++\r\n", 1, NULL);
    f65a:	40 e0       	ldi	r20, 0x00	; 0
    f65c:	50 e0       	ldi	r21, 0x00	; 0
    f65e:	61 e0       	ldi	r22, 0x01	; 1
    f660:	70 e0       	ldi	r23, 0x00	; 0
    f662:	81 e1       	ldi	r24, 0x11	; 17
    f664:	94 e0       	ldi	r25, 0x04	; 4
    f666:	0e 94 63 78 	call	0xf0c6	; 0xf0c6 <sendAT>
	
	// answer with OK indicates about opened TCP connection, close it
	// SUB_TASK_MODEM_CLOSE_TCP
	//sendAT2("AT#SH=%b\r\n", 1, 2, 1, 0, NULL, socket);
	sendAT("AT+QICLOSE=0\r\n",1, NULL );
    f66a:	40 e0       	ldi	r20, 0x00	; 0
    f66c:	50 e0       	ldi	r21, 0x00	; 0
    f66e:	61 e0       	ldi	r22, 0x01	; 1
    f670:	70 e0       	ldi	r23, 0x00	; 0
    f672:	87 e1       	ldi	r24, 0x17	; 23
    f674:	94 e0       	ldi	r25, 0x04	; 4
    f676:	0e 94 63 78 	call	0xf0c6	; 0xf0c6 <sendAT>

	// now close modem
//	sendAT("AT#SHDN\r\n", 1, NULL);
	sendAT("AT+QPOWD\r\n", 1, NULL);
    f67a:	40 e0       	ldi	r20, 0x00	; 0
    f67c:	50 e0       	ldi	r21, 0x00	; 0
    f67e:	61 e0       	ldi	r22, 0x01	; 1
    f680:	70 e0       	ldi	r23, 0x00	; 0
    f682:	86 e2       	ldi	r24, 0x26	; 38
    f684:	94 e0       	ldi	r25, 0x04	; 4
    f686:	0e 94 63 78 	call	0xf0c6	; 0xf0c6 <sendAT>
    f68a:	cf e0       	ldi	r28, 0x0F	; 15

	// wait additional time
	for (retry = 0; retry < 15; retry++)
	{
		if (!isModemOn()) break;
    f68c:	0e 94 d9 76 	call	0xedb2	; 0xedb2 <isModemOn>
    f690:	81 11       	cpse	r24, r1
    f692:	07 c0       	rjmp	.+14     	; 0xf6a2 <closeModem+0x5a>

		delay_secs(1);
	}

	// perform hardware shutdown if needed
	if (isModemOn())
    f694:	0e 94 d9 76 	call	0xedb2	; 0xedb2 <isModemOn>
    f698:	88 23       	and	r24, r24
    f69a:	51 f0       	breq	.+20     	; 0xf6b0 <closeModem+0x68>
	{
		modemHwShdn();
    f69c:	0e 94 d7 76 	call	0xedae	; 0xedae <modemHwShdn>
    f6a0:	07 c0       	rjmp	.+14     	; 0xf6b0 <closeModem+0x68>
	// wait additional time
	for (retry = 0; retry < 15; retry++)
	{
		if (!isModemOn()) break;

		delay_secs(1);
    f6a2:	81 e0       	ldi	r24, 0x01	; 1
    f6a4:	90 e0       	ldi	r25, 0x00	; 0
    f6a6:	0e 94 7b 70 	call	0xe0f6	; 0xe0f6 <delay_secs>
    f6aa:	c1 50       	subi	r28, 0x01	; 1
	// now close modem
//	sendAT("AT#SHDN\r\n", 1, NULL);
	sendAT("AT+QPOWD\r\n", 1, NULL);

	// wait additional time
	for (retry = 0; retry < 15; retry++)
    f6ac:	79 f7       	brne	.-34     	; 0xf68c <closeModem+0x44>
    f6ae:	f2 cf       	rjmp	.-28     	; 0xf694 <closeModem+0x4c>
	if (isModemOn())
	{
		modemHwShdn();
	}

	_logs("CLOSE OK");
    f6b0:	81 e3       	ldi	r24, 0x31	; 49
    f6b2:	94 e0       	ldi	r25, 0x04	; 4
    f6b4:	0e 94 a4 72 	call	0xe548	; 0xe548 <logStr>
	return true;
}
    f6b8:	81 e0       	ldi	r24, 0x01	; 1
    f6ba:	cf 91       	pop	r28
    f6bc:	08 95       	ret

0000f6be <boot_program_page>:
int contentLength;

// taken from AVR example
// IMPORTANT: this function should be in BOOTLOADER flash and not in BLSPARE section
void boot_program_page(uint16_t page, uint8_t *buf, unsigned int chunkLength)
{
    f6be:	0f 93       	push	r16
    f6c0:	1f 93       	push	r17
    f6c2:	cf 93       	push	r28
    f6c4:	8a 01       	movw	r16, r20
	uint8_t sreg;
	uint16_t w;

	// Disable interrupts.

	sreg = SREG;
    f6c6:	5f b7       	in	r21, 0x3f	; 63
	cli();
    f6c8:	f8 94       	cli
	    
	WATCHDOG_RESET();
    f6ca:	a8 95       	wdr

	eeprom_busy_wait();
    f6cc:	f9 99       	sbic	0x1f, 1	; 31
    f6ce:	fe cf       	rjmp	.-4      	; 0xf6cc <boot_program_page+0xe>

	WATCHDOG_RESET();
    f6d0:	a8 95       	wdr

	boot_page_erase(page);
    f6d2:	23 e0       	ldi	r18, 0x03	; 3
    f6d4:	fc 01       	movw	r30, r24
    f6d6:	20 93 57 00 	sts	0x0057, r18	; 0x800057 <__TEXT_REGION_LENGTH__+0x7e0057>
    f6da:	e8 95       	spm
	boot_spm_busy_wait();      // Wait until the memory is erased.
    f6dc:	07 b6       	in	r0, 0x37	; 55
    f6de:	00 fc       	sbrc	r0, 0
    f6e0:	fd cf       	rjmp	.-6      	; 0xf6dc <boot_program_page+0x1e>
    f6e2:	a0 e0       	ldi	r26, 0x00	; 0
    f6e4:	b0 e0       	ldi	r27, 0x00	; 0
			_logt('\r');
			_logt('\n');
		}
		#endif

		boot_page_fill (page + i, w);
    f6e6:	c1 e0       	ldi	r28, 0x01	; 1
	boot_spm_busy_wait();      // Wait until the memory is erased.

	for (i = 0; i < SPM_PAGESIZE; i += 2)
	{
		// Set up little-endian word.
		if (i < chunkLength)
    f6e8:	a0 17       	cp	r26, r16
    f6ea:	b1 07       	cpc	r27, r17
    f6ec:	58 f4       	brcc	.+22     	; 0xf704 <boot_program_page+0x46>
		{
			w = *buf++;
    f6ee:	fb 01       	movw	r30, r22
    f6f0:	40 81       	ld	r20, Z
			w += (*buf++) << 8;
    f6f2:	21 81       	ldd	r18, Z+1	; 0x01
    f6f4:	30 e0       	ldi	r19, 0x00	; 0
    f6f6:	32 2f       	mov	r19, r18
    f6f8:	22 27       	eor	r18, r18
    f6fa:	24 0f       	add	r18, r20
    f6fc:	31 1d       	adc	r19, r1
    f6fe:	6e 5f       	subi	r22, 0xFE	; 254
    f700:	7f 4f       	sbci	r23, 0xFF	; 255
    f702:	02 c0       	rjmp	.+4      	; 0xf708 <boot_program_page+0x4a>
		}
		else
		{
			w = 0xFFFF;
    f704:	2f ef       	ldi	r18, 0xFF	; 255
    f706:	3f ef       	ldi	r19, 0xFF	; 255
			_logt('\r');
			_logt('\n');
		}
		#endif

		boot_page_fill (page + i, w);
    f708:	fc 01       	movw	r30, r24
    f70a:	ea 0f       	add	r30, r26
    f70c:	fb 1f       	adc	r31, r27
    f70e:	09 01       	movw	r0, r18
    f710:	c0 93 57 00 	sts	0x0057, r28	; 0x800057 <__TEXT_REGION_LENGTH__+0x7e0057>
    f714:	e8 95       	spm
    f716:	11 24       	eor	r1, r1
	WATCHDOG_RESET();

	boot_page_erase(page);
	boot_spm_busy_wait();      // Wait until the memory is erased.

	for (i = 0; i < SPM_PAGESIZE; i += 2)
    f718:	12 96       	adiw	r26, 0x02	; 2
    f71a:	a1 15       	cp	r26, r1
    f71c:	f1 e0       	ldi	r31, 0x01	; 1
    f71e:	bf 07       	cpc	r27, r31
    f720:	19 f7       	brne	.-58     	; 0xf6e8 <boot_program_page+0x2a>
	#ifdef DebugServer
	_logt('\r');
	_logt('\n');
	#endif

	WATCHDOG_RESET();
    f722:	a8 95       	wdr

	boot_page_write (page);     // Store buffer in flash page.
    f724:	25 e0       	ldi	r18, 0x05	; 5
    f726:	fc 01       	movw	r30, r24
    f728:	20 93 57 00 	sts	0x0057, r18	; 0x800057 <__TEXT_REGION_LENGTH__+0x7e0057>
    f72c:	e8 95       	spm
	boot_spm_busy_wait();       // Wait until the memory is written.
    f72e:	07 b6       	in	r0, 0x37	; 55
    f730:	00 fc       	sbrc	r0, 0
    f732:	fd cf       	rjmp	.-6      	; 0xf72e <boot_program_page+0x70>

	WATCHDOG_RESET();
    f734:	a8 95       	wdr

	// Reenable RWW-section again. We need this if we want to jump back
	// to the application after bootloading.

	boot_rww_enable ();
    f736:	81 e1       	ldi	r24, 0x11	; 17
    f738:	80 93 57 00 	sts	0x0057, r24	; 0x800057 <__TEXT_REGION_LENGTH__+0x7e0057>
    f73c:	e8 95       	spm

	// Re-enable interrupts (if they were ever enabled).
	SREG = sreg;
    f73e:	5f bf       	out	0x3f, r21	; 63
}
    f740:	cf 91       	pop	r28
    f742:	1f 91       	pop	r17
    f744:	0f 91       	pop	r16
    f746:	08 95       	ret

0000f748 <__udivmodhi4>:
    f748:	aa 1b       	sub	r26, r26
    f74a:	bb 1b       	sub	r27, r27
    f74c:	51 e1       	ldi	r21, 0x11	; 17
    f74e:	07 c0       	rjmp	.+14     	; 0xf75e <__udivmodhi4_ep>

0000f750 <__udivmodhi4_loop>:
    f750:	aa 1f       	adc	r26, r26
    f752:	bb 1f       	adc	r27, r27
    f754:	a6 17       	cp	r26, r22
    f756:	b7 07       	cpc	r27, r23
    f758:	10 f0       	brcs	.+4      	; 0xf75e <__udivmodhi4_ep>
    f75a:	a6 1b       	sub	r26, r22
    f75c:	b7 0b       	sbc	r27, r23

0000f75e <__udivmodhi4_ep>:
    f75e:	88 1f       	adc	r24, r24
    f760:	99 1f       	adc	r25, r25
    f762:	5a 95       	dec	r21
    f764:	a9 f7       	brne	.-22     	; 0xf750 <__udivmodhi4_loop>
    f766:	80 95       	com	r24
    f768:	90 95       	com	r25
    f76a:	bc 01       	movw	r22, r24
    f76c:	cd 01       	movw	r24, r26
    f76e:	08 95       	ret

0000f770 <__udivmodsi4>:
    f770:	a1 e2       	ldi	r26, 0x21	; 33
    f772:	1a 2e       	mov	r1, r26
    f774:	aa 1b       	sub	r26, r26
    f776:	bb 1b       	sub	r27, r27
    f778:	fd 01       	movw	r30, r26
    f77a:	0d c0       	rjmp	.+26     	; 0xf796 <__udivmodsi4_ep>

0000f77c <__udivmodsi4_loop>:
    f77c:	aa 1f       	adc	r26, r26
    f77e:	bb 1f       	adc	r27, r27
    f780:	ee 1f       	adc	r30, r30
    f782:	ff 1f       	adc	r31, r31
    f784:	a2 17       	cp	r26, r18
    f786:	b3 07       	cpc	r27, r19
    f788:	e4 07       	cpc	r30, r20
    f78a:	f5 07       	cpc	r31, r21
    f78c:	20 f0       	brcs	.+8      	; 0xf796 <__udivmodsi4_ep>
    f78e:	a2 1b       	sub	r26, r18
    f790:	b3 0b       	sbc	r27, r19
    f792:	e4 0b       	sbc	r30, r20
    f794:	f5 0b       	sbc	r31, r21

0000f796 <__udivmodsi4_ep>:
    f796:	66 1f       	adc	r22, r22
    f798:	77 1f       	adc	r23, r23
    f79a:	88 1f       	adc	r24, r24
    f79c:	99 1f       	adc	r25, r25
    f79e:	1a 94       	dec	r1
    f7a0:	69 f7       	brne	.-38     	; 0xf77c <__udivmodsi4_loop>
    f7a2:	60 95       	com	r22
    f7a4:	70 95       	com	r23
    f7a6:	80 95       	com	r24
    f7a8:	90 95       	com	r25
    f7aa:	9b 01       	movw	r18, r22
    f7ac:	ac 01       	movw	r20, r24
    f7ae:	bd 01       	movw	r22, r26
    f7b0:	cf 01       	movw	r24, r30
    f7b2:	08 95       	ret

0000f7b4 <__umulhisi3>:
    f7b4:	a2 9f       	mul	r26, r18
    f7b6:	b0 01       	movw	r22, r0
    f7b8:	b3 9f       	mul	r27, r19
    f7ba:	c0 01       	movw	r24, r0
    f7bc:	a3 9f       	mul	r26, r19
    f7be:	70 0d       	add	r23, r0
    f7c0:	81 1d       	adc	r24, r1
    f7c2:	11 24       	eor	r1, r1
    f7c4:	91 1d       	adc	r25, r1
    f7c6:	b2 9f       	mul	r27, r18
    f7c8:	70 0d       	add	r23, r0
    f7ca:	81 1d       	adc	r24, r1
    f7cc:	11 24       	eor	r1, r1
    f7ce:	91 1d       	adc	r25, r1
    f7d0:	08 95       	ret

0000f7d2 <memcpy_P>:
    f7d2:	fb 01       	movw	r30, r22
    f7d4:	dc 01       	movw	r26, r24
    f7d6:	02 c0       	rjmp	.+4      	; 0xf7dc <memcpy_P+0xa>
    f7d8:	05 90       	lpm	r0, Z+
    f7da:	0d 92       	st	X+, r0
    f7dc:	41 50       	subi	r20, 0x01	; 1
    f7de:	50 40       	sbci	r21, 0x00	; 0
    f7e0:	d8 f7       	brcc	.-10     	; 0xf7d8 <memcpy_P+0x6>
    f7e2:	08 95       	ret

0000f7e4 <strcmp>:
    f7e4:	fb 01       	movw	r30, r22
    f7e6:	dc 01       	movw	r26, r24
    f7e8:	8d 91       	ld	r24, X+
    f7ea:	01 90       	ld	r0, Z+
    f7ec:	80 19       	sub	r24, r0
    f7ee:	01 10       	cpse	r0, r1
    f7f0:	d9 f3       	breq	.-10     	; 0xf7e8 <strcmp+0x4>
    f7f2:	99 0b       	sbc	r25, r25
    f7f4:	08 95       	ret

0000f7f6 <strcpy>:
    f7f6:	fb 01       	movw	r30, r22
    f7f8:	dc 01       	movw	r26, r24
    f7fa:	01 90       	ld	r0, Z+
    f7fc:	0d 92       	st	X+, r0
    f7fe:	00 20       	and	r0, r0
    f800:	e1 f7       	brne	.-8      	; 0xf7fa <strcpy+0x4>
    f802:	08 95       	ret

0000f804 <eeprom_read_block>:
    f804:	dc 01       	movw	r26, r24
    f806:	cb 01       	movw	r24, r22

0000f808 <eeprom_read_blraw>:
    f808:	fc 01       	movw	r30, r24
    f80a:	f9 99       	sbic	0x1f, 1	; 31
    f80c:	fe cf       	rjmp	.-4      	; 0xf80a <eeprom_read_blraw+0x2>
    f80e:	06 c0       	rjmp	.+12     	; 0xf81c <eeprom_read_blraw+0x14>
    f810:	f2 bd       	out	0x22, r31	; 34
    f812:	e1 bd       	out	0x21, r30	; 33
    f814:	f8 9a       	sbi	0x1f, 0	; 31
    f816:	31 96       	adiw	r30, 0x01	; 1
    f818:	00 b4       	in	r0, 0x20	; 32
    f81a:	0d 92       	st	X+, r0
    f81c:	41 50       	subi	r20, 0x01	; 1
    f81e:	50 40       	sbci	r21, 0x00	; 0
    f820:	b8 f7       	brcc	.-18     	; 0xf810 <eeprom_read_blraw+0x8>
    f822:	08 95       	ret

0000f824 <eeprom_write_block>:
    f824:	dc 01       	movw	r26, r24
    f826:	cb 01       	movw	r24, r22
    f828:	03 c0       	rjmp	.+6      	; 0xf830 <eeprom_write_block+0xc>
    f82a:	2d 91       	ld	r18, X+
    f82c:	0e 94 1d 7c 	call	0xf83a	; 0xf83a <eeprom_write_r18>
    f830:	41 50       	subi	r20, 0x01	; 1
    f832:	50 40       	sbci	r21, 0x00	; 0
    f834:	d0 f7       	brcc	.-12     	; 0xf82a <eeprom_write_block+0x6>
    f836:	08 95       	ret

0000f838 <eeprom_write_byte>:
    f838:	26 2f       	mov	r18, r22

0000f83a <eeprom_write_r18>:
    f83a:	f9 99       	sbic	0x1f, 1	; 31
    f83c:	fe cf       	rjmp	.-4      	; 0xf83a <eeprom_write_r18>
    f83e:	1f ba       	out	0x1f, r1	; 31
    f840:	92 bd       	out	0x22, r25	; 34
    f842:	81 bd       	out	0x21, r24	; 33
    f844:	20 bd       	out	0x20, r18	; 32
    f846:	0f b6       	in	r0, 0x3f	; 63
    f848:	f8 94       	cli
    f84a:	fa 9a       	sbi	0x1f, 2	; 31
    f84c:	f9 9a       	sbi	0x1f, 1	; 31
    f84e:	0f be       	out	0x3f, r0	; 63
    f850:	01 96       	adiw	r24, 0x01	; 1
    f852:	08 95       	ret

0000f854 <_exit>:
    f854:	f8 94       	cli

0000f856 <__stop_program>:
    f856:	ff cf       	rjmp	.-2      	; 0xf856 <__stop_program>

Disassembly of section .blspare:

0000d000 <WakeUpProcedure>:

void logHexByte(byte b)
{
	logTx(hex[(b >> 4) & 0xF]);
	logTx(hex[b & 0xF]);
	logTx(' ');
    d000:	0e 94 ca 70 	call	0xe194	; 0xe194 <InitProgram>
    d004:	0e 94 13 71 	call	0xe226	; 0xe226 <InitPeripherals>
    d008:	98 e1       	ldi	r25, 0x18	; 24
    d00a:	90 93 c1 00 	sts	0x00C1, r25	; 0x8000c1 <__DATA_REGION_ORIGIN__+0x61>
    d00e:	80 91 6f 00 	lds	r24, 0x006F	; 0x80006f <__DATA_REGION_ORIGIN__+0xf>
    d012:	82 60       	ori	r24, 0x02	; 2
    d014:	80 93 6f 00 	sts	0x006F, r24	; 0x80006f <__DATA_REGION_ORIGIN__+0xf>
    d018:	8b b1       	in	r24, 0x0b	; 11
    d01a:	8f 7c       	andi	r24, 0xCF	; 207
    d01c:	80 62       	ori	r24, 0x20	; 32
    d01e:	8b b9       	out	0x0b, r24	; 11
    d020:	90 93 c9 00 	sts	0x00C9, r25	; 0x8000c9 <__DATA_REGION_ORIGIN__+0x69>
    d024:	82 e3       	ldi	r24, 0x32	; 50
    d026:	90 e0       	ldi	r25, 0x00	; 0
    d028:	0e 94 67 70 	call	0xe0ce	; 0xe0ce <delay_ms>
    d02c:	82 e0       	ldi	r24, 0x02	; 2
    d02e:	91 e0       	ldi	r25, 0x01	; 1
    d030:	0e 94 a4 72 	call	0xe548	; 0xe548 <logStr>
    d034:	0e 94 73 75 	call	0xeae6	; 0xeae6 <MeasureBatt>
    d038:	80 91 3f 06 	lds	r24, 0x063F	; 0x80063f <iVoltage>
    d03c:	90 91 40 06 	lds	r25, 0x0640	; 0x800640 <iVoltage+0x1>
    d040:	89 3d       	cpi	r24, 0xD9	; 217
    d042:	9e 40       	sbci	r25, 0x0E	; 14
    d044:	1c f0       	brlt	.+6      	; 0xd04c <WakeUpProcedure+0x4c>
    d046:	10 92 3e 06 	sts	0x063E, r1	; 0x80063e <btrStatus>
    d04a:	03 c0       	rjmp	.+6      	; 0xd052 <WakeUpProcedure+0x52>
    d04c:	81 e0       	ldi	r24, 0x01	; 1
    d04e:	80 93 3e 06 	sts	0x063E, r24	; 0x80063e <btrStatus>
    d052:	89 e0       	ldi	r24, 0x09	; 9
    d054:	91 e0       	ldi	r25, 0x01	; 1
    d056:	0e 94 a4 72 	call	0xe548	; 0xe548 <logStr>
    d05a:	84 b7       	in	r24, 0x34	; 52
    d05c:	87 7f       	andi	r24, 0xF7	; 247
    d05e:	84 bf       	out	0x34, r24	; 52
    d060:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
    d064:	88 61       	ori	r24, 0x18	; 24
    d066:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
    d06a:	10 92 60 00 	sts	0x0060, r1	; 0x800060 <__DATA_REGION_ORIGIN__>
    d06e:	a8 95       	wdr
    d070:	89 e3       	ldi	r24, 0x39	; 57
    d072:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
    d076:	89 e2       	ldi	r24, 0x29	; 41
    d078:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
    d07c:	84 b7       	in	r24, 0x34	; 52
    d07e:	1f 92       	push	r1
    d080:	8f 93       	push	r24
    d082:	83 e1       	ldi	r24, 0x13	; 19
    d084:	91 e0       	ldi	r25, 0x01	; 1
    d086:	9f 93       	push	r25
    d088:	8f 93       	push	r24
    d08a:	0e 94 aa 72 	call	0xe554	; 0xe554 <logd>
    d08e:	0f 90       	pop	r0
    d090:	0f 90       	pop	r0
    d092:	0f 90       	pop	r0
    d094:	0f 90       	pop	r0
    d096:	08 95       	ret

0000d098 <turnModemOn>:
	{
		return false;
	}
	
	return status == 1;
}
    d098:	7f 92       	push	r7
    d09a:	8f 92       	push	r8
    d09c:	9f 92       	push	r9
    d09e:	af 92       	push	r10
    d0a0:	bf 92       	push	r11
    d0a2:	cf 92       	push	r12
    d0a4:	df 92       	push	r13
    d0a6:	ef 92       	push	r14
    d0a8:	ff 92       	push	r15
    d0aa:	0f 93       	push	r16
    d0ac:	1f 93       	push	r17
    d0ae:	cf 93       	push	r28
    d0b0:	df 93       	push	r29
    d0b2:	e8 2e       	mov	r14, r24
    d0b4:	c1 e0       	ldi	r28, 0x01	; 1
    d0b6:	d0 e0       	ldi	r29, 0x00	; 0
    d0b8:	8c e7       	ldi	r24, 0x7C	; 124
    d0ba:	c8 2e       	mov	r12, r24
    d0bc:	82 e0       	ldi	r24, 0x02	; 2
    d0be:	d8 2e       	mov	r13, r24
    d0c0:	90 ea       	ldi	r25, 0xA0	; 160
    d0c2:	a9 2e       	mov	r10, r25
    d0c4:	92 e0       	ldi	r25, 0x02	; 2
    d0c6:	b9 2e       	mov	r11, r25
    d0c8:	2f ea       	ldi	r18, 0xAF	; 175
    d0ca:	82 2e       	mov	r8, r18
    d0cc:	22 e0       	ldi	r18, 0x02	; 2
    d0ce:	92 2e       	mov	r9, r18
    d0d0:	32 e0       	ldi	r19, 0x02	; 2
    d0d2:	73 2e       	mov	r7, r19
    d0d4:	43 e0       	ldi	r20, 0x03	; 3
    d0d6:	f4 2e       	mov	r15, r20
    d0d8:	0b eb       	ldi	r16, 0xBB	; 187
    d0da:	12 e0       	ldi	r17, 0x02	; 2
    d0dc:	df 93       	push	r29
    d0de:	cf 93       	push	r28
    d0e0:	df 92       	push	r13
    d0e2:	cf 92       	push	r12
    d0e4:	0e 94 aa 72 	call	0xe554	; 0xe554 <logd>
    d0e8:	0e 94 d9 76 	call	0xedb2	; 0xedb2 <isModemOn>
    d0ec:	0f 90       	pop	r0
    d0ee:	0f 90       	pop	r0
    d0f0:	0f 90       	pop	r0
    d0f2:	0f 90       	pop	r0
    d0f4:	88 23       	and	r24, r24
    d0f6:	21 f0       	breq	.+8      	; 0xd100 <turnModemOn+0x68>
    d0f8:	c1 30       	cpi	r28, 0x01	; 1
    d0fa:	11 f4       	brne	.+4      	; 0xd100 <turnModemOn+0x68>
    d0fc:	ee 20       	and	r14, r14
    d0fe:	a9 f0       	breq	.+42     	; 0xd12a <turnModemOn+0x92>
    d100:	83 e9       	ldi	r24, 0x93	; 147
    d102:	92 e0       	ldi	r25, 0x02	; 2
    d104:	0e 94 a4 72 	call	0xe548	; 0xe548 <logStr>
    d108:	5f 9a       	sbi	0x0b, 7	; 11
    d10a:	88 ee       	ldi	r24, 0xE8	; 232
    d10c:	93 e0       	ldi	r25, 0x03	; 3
    d10e:	0e 94 7b 70 	call	0xe0f6	; 0xe0f6 <delay_secs>
    d112:	0e 94 d3 76 	call	0xeda6	; 0xeda6 <turnOnIgnition>
    d116:	81 e0       	ldi	r24, 0x01	; 1
    d118:	90 e0       	ldi	r25, 0x00	; 0
    d11a:	0e 94 7b 70 	call	0xe0f6	; 0xe0f6 <delay_secs>
    d11e:	0e 94 d5 76 	call	0xedaa	; 0xedaa <turnOffIgnition>
    d122:	8f e0       	ldi	r24, 0x0F	; 15
    d124:	90 e0       	ldi	r25, 0x00	; 0
    d126:	0e 94 7b 70 	call	0xe0f6	; 0xe0f6 <delay_secs>
    d12a:	bf 92       	push	r11
    d12c:	af 92       	push	r10
    d12e:	0e 94 aa 72 	call	0xe554	; 0xe554 <logd>
    d132:	0e 94 d9 76 	call	0xedb2	; 0xedb2 <isModemOn>
    d136:	1f 92       	push	r1
    d138:	8f 93       	push	r24
    d13a:	9f 92       	push	r9
    d13c:	8f 92       	push	r8
    d13e:	0e 94 aa 72 	call	0xe554	; 0xe554 <logd>
    d142:	0f 90       	pop	r0
    d144:	0f 90       	pop	r0
    d146:	0f 90       	pop	r0
    d148:	0f 90       	pop	r0
    d14a:	0f 90       	pop	r0
    d14c:	0f 90       	pop	r0
    d14e:	ee 20       	and	r14, r14
    d150:	79 f0       	breq	.+30     	; 0xd170 <turnModemOn+0xd8>
    d152:	df 91       	pop	r29
    d154:	cf 91       	pop	r28
    d156:	1f 91       	pop	r17
    d158:	0f 91       	pop	r16
    d15a:	ff 90       	pop	r15
    d15c:	ef 90       	pop	r14
    d15e:	df 90       	pop	r13
    d160:	cf 90       	pop	r12
    d162:	bf 90       	pop	r11
    d164:	af 90       	pop	r10
    d166:	9f 90       	pop	r9
    d168:	8f 90       	pop	r8
    d16a:	7f 90       	pop	r7
    d16c:	0c 94 d9 76 	jmp	0xedb2	; 0xedb2 <isModemOn>
    d170:	0e 94 d9 76 	call	0xedb2	; 0xedb2 <isModemOn>
    d174:	81 11       	cpse	r24, r1
    d176:	0d c0       	rjmp	.+26     	; 0xd192 <turnModemOn+0xfa>
    d178:	0e 94 d7 76 	call	0xedae	; 0xedae <modemHwShdn>
    d17c:	81 e0       	ldi	r24, 0x01	; 1
    d17e:	90 e0       	ldi	r25, 0x00	; 0
    d180:	0e 94 7b 70 	call	0xe0f6	; 0xe0f6 <delay_secs>
    d184:	21 96       	adiw	r28, 0x01	; 1
    d186:	c4 30       	cpi	r28, 0x04	; 4
    d188:	d1 05       	cpc	r29, r1
    d18a:	09 f0       	breq	.+2      	; 0xd18e <turnModemOn+0xf6>
    d18c:	a7 cf       	rjmp	.-178    	; 0xd0dc <turnModemOn+0x44>
    d18e:	80 e0       	ldi	r24, 0x00	; 0
    d190:	1e c0       	rjmp	.+60     	; 0xd1ce <turnModemOn+0x136>
    d192:	81 e0       	ldi	r24, 0x01	; 1
    d194:	90 e0       	ldi	r25, 0x00	; 0
    d196:	0e 94 7b 70 	call	0xe0f6	; 0xe0f6 <delay_secs>
    d19a:	1f 92       	push	r1
    d19c:	1f 92       	push	r1
    d19e:	1f 92       	push	r1
    d1a0:	1f 92       	push	r1
    d1a2:	1f 92       	push	r1
    d1a4:	7f 92       	push	r7
    d1a6:	1f 92       	push	r1
    d1a8:	ff 92       	push	r15
    d1aa:	1f 92       	push	r1
    d1ac:	ff 92       	push	r15
    d1ae:	1f 93       	push	r17
    d1b0:	0f 93       	push	r16
    d1b2:	0e 94 7e 78 	call	0xf0fc	; 0xf0fc <sendAT2>
    d1b6:	2d b7       	in	r18, 0x3d	; 61
    d1b8:	3e b7       	in	r19, 0x3e	; 62
    d1ba:	24 5f       	subi	r18, 0xF4	; 244
    d1bc:	3f 4f       	sbci	r19, 0xFF	; 255
    d1be:	0f b6       	in	r0, 0x3f	; 63
    d1c0:	f8 94       	cli
    d1c2:	3e bf       	out	0x3e, r19	; 62
    d1c4:	0f be       	out	0x3f, r0	; 63
    d1c6:	2d bf       	out	0x3d, r18	; 61
    d1c8:	81 11       	cpse	r24, r1
    d1ca:	d6 cf       	rjmp	.-84     	; 0xd178 <turnModemOn+0xe0>
    d1cc:	81 e0       	ldi	r24, 0x01	; 1
    d1ce:	df 91       	pop	r29
    d1d0:	cf 91       	pop	r28
    d1d2:	1f 91       	pop	r17
    d1d4:	0f 91       	pop	r16
    d1d6:	ff 90       	pop	r15
    d1d8:	ef 90       	pop	r14
    d1da:	df 90       	pop	r13
    d1dc:	cf 90       	pop	r12
    d1de:	bf 90       	pop	r11
    d1e0:	af 90       	pop	r10
    d1e2:	9f 90       	pop	r9
    d1e4:	8f 90       	pop	r8
    d1e6:	7f 90       	pop	r7
    d1e8:	08 95       	ret

0000d1ea <parseFileChunkHeaders>:
	return false;
}

bool BLSPARE parseFileChunkHeaders(char* header)
{
	if (qscanf(header, "Content-Length: %d", &contentLength) == 1)
    d1ea:	24 ee       	ldi	r18, 0xE4	; 228
    d1ec:	3e e0       	ldi	r19, 0x0E	; 14
    d1ee:	3f 93       	push	r19
    d1f0:	2f 93       	push	r18
    d1f2:	2a e3       	ldi	r18, 0x3A	; 58
    d1f4:	34 e0       	ldi	r19, 0x04	; 4
    d1f6:	3f 93       	push	r19
    d1f8:	2f 93       	push	r18
    d1fa:	9f 93       	push	r25
    d1fc:	8f 93       	push	r24
    d1fe:	0e 94 3e 71 	call	0xe27c	; 0xe27c <qscanf>
    d202:	21 e0       	ldi	r18, 0x01	; 1
    d204:	0f 90       	pop	r0
    d206:	0f 90       	pop	r0
    d208:	0f 90       	pop	r0
    d20a:	0f 90       	pop	r0
    d20c:	0f 90       	pop	r0
    d20e:	0f 90       	pop	r0
    d210:	01 97       	sbiw	r24, 0x01	; 1
    d212:	09 f0       	breq	.+2      	; 0xd216 <parseFileChunkHeaders+0x2c>
    d214:	20 e0       	ldi	r18, 0x00	; 0
	{
		return true;
	}

	return false;
}
    d216:	82 2f       	mov	r24, r18
    d218:	08 95       	ret

0000d21a <parseFileInfoHeaders>:
    d21a:	0c 94 f5 68 	jmp	0xd1ea	; 0xd1ea <parseFileChunkHeaders>

0000d21e <isHTTPOK>:
	SREG = sreg;
}

bool BLSPARE isHTTPOK()
{
	return qscanf(getResponse(), "HTTP/1.1 200 %e") == 1;
    d21e:	0e 94 b4 76 	call	0xed68	; 0xed68 <getResponse>
    d222:	2d e4       	ldi	r18, 0x4D	; 77
    d224:	34 e0       	ldi	r19, 0x04	; 4
    d226:	3f 93       	push	r19
    d228:	2f 93       	push	r18
    d22a:	9f 93       	push	r25
    d22c:	8f 93       	push	r24
    d22e:	0e 94 3e 71 	call	0xe27c	; 0xe27c <qscanf>
    d232:	21 e0       	ldi	r18, 0x01	; 1
    d234:	0f 90       	pop	r0
    d236:	0f 90       	pop	r0
    d238:	0f 90       	pop	r0
    d23a:	0f 90       	pop	r0
    d23c:	01 97       	sbiw	r24, 0x01	; 1
    d23e:	09 f0       	breq	.+2      	; 0xd242 <isHTTPOK+0x24>
    d240:	20 e0       	ldi	r18, 0x00	; 0
}
    d242:	82 2f       	mov	r24, r18
    d244:	08 95       	ret

0000d246 <isHTTPPartial>:

bool BLSPARE isHTTPPartial()
{
	return qscanf(getResponse(), "HTTP/1.1 206 %e") == 1;
    d246:	0e 94 b4 76 	call	0xed68	; 0xed68 <getResponse>
    d24a:	2d e5       	ldi	r18, 0x5D	; 93
    d24c:	34 e0       	ldi	r19, 0x04	; 4
    d24e:	3f 93       	push	r19
    d250:	2f 93       	push	r18
    d252:	9f 93       	push	r25
    d254:	8f 93       	push	r24
    d256:	0e 94 3e 71 	call	0xe27c	; 0xe27c <qscanf>
    d25a:	21 e0       	ldi	r18, 0x01	; 1
    d25c:	0f 90       	pop	r0
    d25e:	0f 90       	pop	r0
    d260:	0f 90       	pop	r0
    d262:	0f 90       	pop	r0
    d264:	01 97       	sbiw	r24, 0x01	; 1
    d266:	09 f0       	breq	.+2      	; 0xd26a <isHTTPPartial+0x24>
    d268:	20 e0       	ldi	r18, 0x00	; 0
}
    d26a:	82 2f       	mov	r24, r18
    d26c:	08 95       	ret

0000d26e <getFirmwareLength>:

	return false;
}

bool BLSPARE getFirmwareLength(unsigned int version)
{
    d26e:	af 92       	push	r10
    d270:	bf 92       	push	r11
    d272:	cf 92       	push	r12
    d274:	df 92       	push	r13
    d276:	ef 92       	push	r14
    d278:	ff 92       	push	r15
    d27a:	0f 93       	push	r16
    d27c:	1f 93       	push	r17
    d27e:	cf 93       	push	r28
    d280:	df 93       	push	r29
    d282:	d8 2f       	mov	r29, r24
    d284:	b9 2e       	mov	r11, r25
    d286:	c3 e0       	ldi	r28, 0x03	; 3
	for (retries = 0; retries < HTTP_RETRIES; retries++, delay_secs(HTTP_PAUSE_BETWEEN_RETRIES))
	{
		contentLength = 0;

		// first send request to server to get file information
		if (sendHTTP("HEAD /firmware/%d HTTP/1.1\r\nHost: %s\r\nUser-Agent: logger/1.0\r\n\r\n", 20, parseFileInfoHeaders, version, FIRMWARE_HOST_URL) != 1)
    d288:	0f eb       	ldi	r16, 0xBF	; 191
    d28a:	13 e0       	ldi	r17, 0x03	; 3
    d28c:	8d e0       	ldi	r24, 0x0D	; 13
    d28e:	e8 2e       	mov	r14, r24
    d290:	89 e6       	ldi	r24, 0x69	; 105
    d292:	f8 2e       	mov	r15, r24
    d294:	94 e1       	ldi	r25, 0x14	; 20
    d296:	a9 2e       	mov	r10, r25
    d298:	2d e6       	ldi	r18, 0x6D	; 109
    d29a:	c2 2e       	mov	r12, r18
    d29c:	24 e0       	ldi	r18, 0x04	; 4
    d29e:	d2 2e       	mov	r13, r18
{
	byte retries;

	for (retries = 0; retries < HTTP_RETRIES; retries++, delay_secs(HTTP_PAUSE_BETWEEN_RETRIES))
	{
		contentLength = 0;
    d2a0:	10 92 e5 0e 	sts	0x0EE5, r1	; 0x800ee5 <contentLength+0x1>
    d2a4:	10 92 e4 0e 	sts	0x0EE4, r1	; 0x800ee4 <contentLength>

		// first send request to server to get file information
		if (sendHTTP("HEAD /firmware/%d HTTP/1.1\r\nHost: %s\r\nUser-Agent: logger/1.0\r\n\r\n", 20, parseFileInfoHeaders, version, FIRMWARE_HOST_URL) != 1)
    d2a8:	1f 93       	push	r17
    d2aa:	0f 93       	push	r16
    d2ac:	bf 92       	push	r11
    d2ae:	df 93       	push	r29
    d2b0:	ff 92       	push	r15
    d2b2:	ef 92       	push	r14
    d2b4:	1f 92       	push	r1
    d2b6:	af 92       	push	r10
    d2b8:	df 92       	push	r13
    d2ba:	cf 92       	push	r12
    d2bc:	0e 94 bd 78 	call	0xf17a	; 0xf17a <sendHTTP>
    d2c0:	2d b7       	in	r18, 0x3d	; 61
    d2c2:	3e b7       	in	r19, 0x3e	; 62
    d2c4:	26 5f       	subi	r18, 0xF6	; 246
    d2c6:	3f 4f       	sbci	r19, 0xFF	; 255
    d2c8:	0f b6       	in	r0, 0x3f	; 63
    d2ca:	f8 94       	cli
    d2cc:	3e bf       	out	0x3e, r19	; 62
    d2ce:	0f be       	out	0x3f, r0	; 63
    d2d0:	2d bf       	out	0x3d, r18	; 61
    d2d2:	81 30       	cpi	r24, 0x01	; 1
    d2d4:	41 f0       	breq	.+16     	; 0xd2e6 <getFirmwareLength+0x78>

bool BLSPARE getFirmwareLength(unsigned int version)
{
	byte retries;

	for (retries = 0; retries < HTTP_RETRIES; retries++, delay_secs(HTTP_PAUSE_BETWEEN_RETRIES))
    d2d6:	82 e0       	ldi	r24, 0x02	; 2
    d2d8:	90 e0       	ldi	r25, 0x00	; 0
    d2da:	0e 94 7b 70 	call	0xe0f6	; 0xe0f6 <delay_secs>
    d2de:	c1 50       	subi	r28, 0x01	; 1
    d2e0:	f9 f6       	brne	.-66     	; 0xd2a0 <getFirmwareLength+0x32>
		{
			return true;
		}
	}

	return false;
    d2e2:	80 e0       	ldi	r24, 0x00	; 0
    d2e4:	0b c0       	rjmp	.+22     	; 0xd2fc <getFirmwareLength+0x8e>
		{
			continue;
		}

		// now we can parse response
		if (!isHTTPOK())
    d2e6:	0e 94 0f 69 	call	0xd21e	; 0xd21e <isHTTPOK>
    d2ea:	88 23       	and	r24, r24
    d2ec:	a1 f3       	breq	.-24     	; 0xd2d6 <getFirmwareLength+0x68>
		{
			continue;
		}

		// content length is found
		if (contentLength != 0)
    d2ee:	80 91 e4 0e 	lds	r24, 0x0EE4	; 0x800ee4 <contentLength>
    d2f2:	90 91 e5 0e 	lds	r25, 0x0EE5	; 0x800ee5 <contentLength+0x1>
    d2f6:	89 2b       	or	r24, r25
    d2f8:	71 f3       	breq	.-36     	; 0xd2d6 <getFirmwareLength+0x68>
		{
			return true;
    d2fa:	81 e0       	ldi	r24, 0x01	; 1
		}
	}

	return false;
}
    d2fc:	df 91       	pop	r29
    d2fe:	cf 91       	pop	r28
    d300:	1f 91       	pop	r17
    d302:	0f 91       	pop	r16
    d304:	ff 90       	pop	r15
    d306:	ef 90       	pop	r14
    d308:	df 90       	pop	r13
    d30a:	cf 90       	pop	r12
    d30c:	bf 90       	pop	r11
    d30e:	af 90       	pop	r10
    d310:	08 95       	ret

0000d312 <downloadFirmware>:
	
	return true;
}

bool BLSPARE downloadFirmware(unsigned int version)
{
    d312:	2f 92       	push	r2
    d314:	3f 92       	push	r3
    d316:	4f 92       	push	r4
    d318:	5f 92       	push	r5
    d31a:	6f 92       	push	r6
    d31c:	7f 92       	push	r7
    d31e:	8f 92       	push	r8
    d320:	9f 92       	push	r9
    d322:	af 92       	push	r10
    d324:	bf 92       	push	r11
    d326:	cf 92       	push	r12
    d328:	df 92       	push	r13
    d32a:	ef 92       	push	r14
    d32c:	ff 92       	push	r15
    d32e:	0f 93       	push	r16
    d330:	1f 93       	push	r17
    d332:	cf 93       	push	r28
    d334:	df 93       	push	r29
    d336:	48 2e       	mov	r4, r24
    d338:	39 2e       	mov	r3, r25
	unsigned int chunkLength;
	byte retries;
	byte* httpBody;

	// first ask server for firmware file length
	if (!getFirmwareLength(version)) return false;
    d33a:	0e 94 37 69 	call	0xd26e	; 0xd26e <getFirmwareLength>
    d33e:	81 11       	cpse	r24, r1
    d340:	02 c0       	rjmp	.+4      	; 0xd346 <downloadFirmware+0x34>
    d342:	80 e0       	ldi	r24, 0x00	; 0
    d344:	9b c0       	rjmp	.+310    	; 0xd47c <downloadFirmware+0x16a>

	// now start getting file by chunks of SPM_PAGESIZE bytes
	offset = 0;
	length = contentLength;
    d346:	e0 90 e4 0e 	lds	r14, 0x0EE4	; 0x800ee4 <contentLength>
    d34a:	f0 90 e5 0e 	lds	r15, 0x0EE5	; 0x800ee5 <contentLength+0x1>

	// first ask server for firmware file length
	if (!getFirmwareLength(version)) return false;

	// now start getting file by chunks of SPM_PAGESIZE bytes
	offset = 0;
    d34e:	c0 e0       	ldi	r28, 0x00	; 0
    d350:	d0 e0       	ldi	r29, 0x00	; 0
		{
			chunkLength = (length - offset) > (SPM_PAGESIZE * FLASH_PAGES_PER_REQUEST) ? (SPM_PAGESIZE * FLASH_PAGES_PER_REQUEST) : (length - offset);
			contentLength = 0;

			// first send request to server to get file information
			if (sendHTTP("GET /firmware/%d HTTP/1.1\r\nHost: %s\r\nRange: bytes=%d-%d\r\nUser-Agent: logger/1.0\r\n\r\n", 20, parseFileChunkHeaders,
    d352:	94 e1       	ldi	r25, 0x14	; 20
    d354:	29 2e       	mov	r2, r25
			if (!isHTTPPartial())
			{
				continue;
			}

			_logd("Chunk: l %d req %d body %d", contentLength, chunkLength, getHttpBodyLength());
    d356:	22 e0       	ldi	r18, 0x02	; 2
    d358:	82 2e       	mov	r8, r18
    d35a:	25 e0       	ldi	r18, 0x05	; 5
    d35c:	92 2e       	mov	r9, r18

	// now start getting file by chunks of SPM_PAGESIZE bytes
	offset = 0;
	length = contentLength;

	while (offset < length)
    d35e:	ce 15       	cp	r28, r14
    d360:	df 05       	cpc	r29, r15
    d362:	08 f0       	brcs	.+2      	; 0xd366 <downloadFirmware+0x54>
    d364:	86 c0       	rjmp	.+268    	; 0xd472 <downloadFirmware+0x160>
    d366:	83 e0       	ldi	r24, 0x03	; 3
    d368:	58 2e       	mov	r5, r24
	{
		for (retries = 0; retries < HTTP_RETRIES; retries++, delay_secs(HTTP_PAUSE_BETWEEN_RETRIES))
		{
			chunkLength = (length - offset) > (SPM_PAGESIZE * FLASH_PAGES_PER_REQUEST) ? (SPM_PAGESIZE * FLASH_PAGES_PER_REQUEST) : (length - offset);
    d36a:	67 01       	movw	r12, r14
    d36c:	cc 1a       	sub	r12, r28
    d36e:	dd 0a       	sbc	r13, r29
			contentLength = 0;

			// first send request to server to get file information
			if (sendHTTP("GET /firmware/%d HTTP/1.1\r\nHost: %s\r\nRange: bytes=%d-%d\r\nUser-Agent: logger/1.0\r\n\r\n", 20, parseFileChunkHeaders,
    d370:	5e 01       	movw	r10, r28
    d372:	21 e0       	ldi	r18, 0x01	; 1
    d374:	a2 1a       	sub	r10, r18
    d376:	b1 08       	sbc	r11, r1

	while (offset < length)
	{
		for (retries = 0; retries < HTTP_RETRIES; retries++, delay_secs(HTTP_PAUSE_BETWEEN_RETRIES))
		{
			chunkLength = (length - offset) > (SPM_PAGESIZE * FLASH_PAGES_PER_REQUEST) ? (SPM_PAGESIZE * FLASH_PAGES_PER_REQUEST) : (length - offset);
    d378:	86 01       	movw	r16, r12
    d37a:	31 e0       	ldi	r19, 0x01	; 1
    d37c:	c3 16       	cp	r12, r19
    d37e:	36 e0       	ldi	r19, 0x06	; 6
    d380:	d3 06       	cpc	r13, r19
    d382:	10 f0       	brcs	.+4      	; 0xd388 <downloadFirmware+0x76>
    d384:	00 e0       	ldi	r16, 0x00	; 0
    d386:	16 e0       	ldi	r17, 0x06	; 6
			contentLength = 0;
    d388:	10 92 e5 0e 	sts	0x0EE5, r1	; 0x800ee5 <contentLength+0x1>
    d38c:	10 92 e4 0e 	sts	0x0EE4, r1	; 0x800ee4 <contentLength>

			// first send request to server to get file information
			if (sendHTTP("GET /firmware/%d HTTP/1.1\r\nHost: %s\r\nRange: bytes=%d-%d\r\nUser-Agent: logger/1.0\r\n\r\n", 20, parseFileChunkHeaders,
    d390:	c5 01       	movw	r24, r10
    d392:	80 0f       	add	r24, r16
    d394:	91 1f       	adc	r25, r17
    d396:	9f 93       	push	r25
    d398:	8f 93       	push	r24
    d39a:	df 93       	push	r29
    d39c:	cf 93       	push	r28
    d39e:	2f eb       	ldi	r18, 0xBF	; 191
    d3a0:	33 e0       	ldi	r19, 0x03	; 3
    d3a2:	3f 93       	push	r19
    d3a4:	2f 93       	push	r18
    d3a6:	3f 92       	push	r3
    d3a8:	4f 92       	push	r4
    d3aa:	25 ef       	ldi	r18, 0xF5	; 245
    d3ac:	38 e6       	ldi	r19, 0x68	; 104
    d3ae:	3f 93       	push	r19
    d3b0:	2f 93       	push	r18
    d3b2:	1f 92       	push	r1
    d3b4:	2f 92       	push	r2
    d3b6:	2e ea       	ldi	r18, 0xAE	; 174
    d3b8:	34 e0       	ldi	r19, 0x04	; 4
    d3ba:	3f 93       	push	r19
    d3bc:	2f 93       	push	r18
    d3be:	0e 94 bd 78 	call	0xf17a	; 0xf17a <sendHTTP>
    d3c2:	2d b7       	in	r18, 0x3d	; 61
    d3c4:	3e b7       	in	r19, 0x3e	; 62
    d3c6:	22 5f       	subi	r18, 0xF2	; 242
    d3c8:	3f 4f       	sbci	r19, 0xFF	; 255
    d3ca:	0f b6       	in	r0, 0x3f	; 63
    d3cc:	f8 94       	cli
    d3ce:	3e bf       	out	0x3e, r19	; 62
    d3d0:	0f be       	out	0x3f, r0	; 63
    d3d2:	2d bf       	out	0x3d, r18	; 61
    d3d4:	81 30       	cpi	r24, 0x01	; 1
    d3d6:	09 f0       	breq	.+2      	; 0xd3da <downloadFirmware+0xc8>
    d3d8:	44 c0       	rjmp	.+136    	; 0xd462 <downloadFirmware+0x150>
			{
				continue;
			}

			// now we can parse response
			if (!isHTTPPartial())
    d3da:	0e 94 23 69 	call	0xd246	; 0xd246 <isHTTPPartial>
    d3de:	88 23       	and	r24, r24
    d3e0:	09 f4       	brne	.+2      	; 0xd3e4 <downloadFirmware+0xd2>
    d3e2:	3f c0       	rjmp	.+126    	; 0xd462 <downloadFirmware+0x150>
			{
				continue;
			}

			_logd("Chunk: l %d req %d body %d", contentLength, chunkLength, getHttpBodyLength());
    d3e4:	0e 94 c3 76 	call	0xed86	; 0xed86 <getHttpBodyLength>
    d3e8:	9f 93       	push	r25
    d3ea:	8f 93       	push	r24
    d3ec:	1f 93       	push	r17
    d3ee:	0f 93       	push	r16
    d3f0:	80 91 e5 0e 	lds	r24, 0x0EE5	; 0x800ee5 <contentLength+0x1>
    d3f4:	8f 93       	push	r24
    d3f6:	80 91 e4 0e 	lds	r24, 0x0EE4	; 0x800ee4 <contentLength>
    d3fa:	8f 93       	push	r24
    d3fc:	9f 92       	push	r9
    d3fe:	8f 92       	push	r8
    d400:	0e 94 aa 72 	call	0xe554	; 0xe554 <logd>
			// check that we received exact number of bytes requested
			if (getHttpBodyLength() != chunkLength)
    d404:	0e 94 c3 76 	call	0xed86	; 0xed86 <getHttpBodyLength>
    d408:	3c 01       	movw	r6, r24
    d40a:	8d b7       	in	r24, 0x3d	; 61
    d40c:	9e b7       	in	r25, 0x3e	; 62
    d40e:	08 96       	adiw	r24, 0x08	; 8
    d410:	0f b6       	in	r0, 0x3f	; 63
    d412:	f8 94       	cli
    d414:	9e bf       	out	0x3e, r25	; 62
    d416:	0f be       	out	0x3f, r0	; 63
    d418:	8d bf       	out	0x3d, r24	; 61
    d41a:	06 15       	cp	r16, r6
    d41c:	17 05       	cpc	r17, r7
    d41e:	09 f5       	brne	.+66     	; 0xd462 <downloadFirmware+0x150>
			{
				continue;
			}

			httpBody = (byte*)getHttpBody();
    d420:	0e 94 b7 76 	call	0xed6e	; 0xed6e <getHttpBody>
    d424:	8c 01       	movw	r16, r24

			// now we can flush buffer to flash
			while (chunkLength > 0)
    d426:	61 14       	cp	r6, r1
    d428:	71 04       	cpc	r7, r1
    d42a:	09 f4       	brne	.+2      	; 0xd42e <downloadFirmware+0x11c>
    d42c:	98 cf       	rjmp	.-208    	; 0xd35e <downloadFirmware+0x4c>
			{
				contentLength = chunkLength > SPM_PAGESIZE ? SPM_PAGESIZE : chunkLength;
    d42e:	a3 01       	movw	r20, r6
    d430:	91 e0       	ldi	r25, 0x01	; 1
    d432:	69 16       	cp	r6, r25
    d434:	79 06       	cpc	r7, r25
    d436:	10 f0       	brcs	.+4      	; 0xd43c <downloadFirmware+0x12a>
    d438:	40 e0       	ldi	r20, 0x00	; 0
    d43a:	51 e0       	ldi	r21, 0x01	; 1
    d43c:	40 93 e4 0e 	sts	0x0EE4, r20	; 0x800ee4 <contentLength>
    d440:	50 93 e5 0e 	sts	0x0EE5, r21	; 0x800ee5 <contentLength+0x1>

				boot_program_page(offset, httpBody, contentLength);
    d444:	b8 01       	movw	r22, r16
    d446:	ce 01       	movw	r24, r28
    d448:	0e 94 5f 7b 	call	0xf6be	; 0xf6be <boot_program_page>

				offset += contentLength;
    d44c:	80 91 e4 0e 	lds	r24, 0x0EE4	; 0x800ee4 <contentLength>
    d450:	90 91 e5 0e 	lds	r25, 0x0EE5	; 0x800ee5 <contentLength+0x1>
    d454:	c8 0f       	add	r28, r24
    d456:	d9 1f       	adc	r29, r25
				chunkLength -= contentLength;
    d458:	68 1a       	sub	r6, r24
    d45a:	79 0a       	sbc	r7, r25
				httpBody += contentLength;
    d45c:	08 0f       	add	r16, r24
    d45e:	19 1f       	adc	r17, r25
    d460:	e2 cf       	rjmp	.-60     	; 0xd426 <downloadFirmware+0x114>
	offset = 0;
	length = contentLength;

	while (offset < length)
	{
		for (retries = 0; retries < HTTP_RETRIES; retries++, delay_secs(HTTP_PAUSE_BETWEEN_RETRIES))
    d462:	82 e0       	ldi	r24, 0x02	; 2
    d464:	90 e0       	ldi	r25, 0x00	; 0
    d466:	0e 94 7b 70 	call	0xe0f6	; 0xe0f6 <delay_secs>
    d46a:	5a 94       	dec	r5
    d46c:	51 10       	cpse	r5, r1
    d46e:	84 cf       	rjmp	.-248    	; 0xd378 <downloadFirmware+0x66>
    d470:	68 cf       	rjmp	.-304    	; 0xd342 <downloadFirmware+0x30>
		{
			return false;
		}
	}

	_logs("DF OK");
    d472:	8d e1       	ldi	r24, 0x1D	; 29
    d474:	95 e0       	ldi	r25, 0x05	; 5
    d476:	0e 94 a4 72 	call	0xe548	; 0xe548 <logStr>

	//
	// we successfully burned the firmware
	return true;
    d47a:	81 e0       	ldi	r24, 0x01	; 1
}
    d47c:	df 91       	pop	r29
    d47e:	cf 91       	pop	r28
    d480:	1f 91       	pop	r17
    d482:	0f 91       	pop	r16
    d484:	ff 90       	pop	r15
    d486:	ef 90       	pop	r14
    d488:	df 90       	pop	r13
    d48a:	cf 90       	pop	r12
    d48c:	bf 90       	pop	r11
    d48e:	af 90       	pop	r10
    d490:	9f 90       	pop	r9
    d492:	8f 90       	pop	r8
    d494:	7f 90       	pop	r7
    d496:	6f 90       	pop	r6
    d498:	5f 90       	pop	r5
    d49a:	4f 90       	pop	r4
    d49c:	3f 90       	pop	r3
    d49e:	2f 90       	pop	r2
    d4a0:	08 95       	ret

0000d4a2 <updateFirmwareStatus>:

bool BLSPARE updateFirmwareStatus(byte status)
{
    d4a2:	df 92       	push	r13
    d4a4:	ef 92       	push	r14
    d4a6:	ff 92       	push	r15
    d4a8:	0f 93       	push	r16
    d4aa:	1f 93       	push	r17
    d4ac:	cf 93       	push	r28
    d4ae:	df 93       	push	r29
    d4b0:	d8 2f       	mov	r29, r24
    d4b2:	c3 e0       	ldi	r28, 0x03	; 3
	for (retries = 0; retries < HTTP_RETRIES; retries++, delay_secs(HTTP_PAUSE_BETWEEN_RETRIES))
	{
		contentLength = 0;

		// first send request to server to get file information
		if (sendHTTP("PUT /status/%l/%d/%d/%s HTTP/1.1\r\nHost: %s\r\nUser-Agent: logger/1.0\r\n\r\n", 30, NULL,
    d4b4:	0f eb       	ldi	r16, 0xBF	; 191
    d4b6:	13 e0       	ldi	r17, 0x03	; 3
    d4b8:	8e e1       	ldi	r24, 0x1E	; 30
    d4ba:	d8 2e       	mov	r13, r24
    d4bc:	93 e2       	ldi	r25, 0x23	; 35
    d4be:	e9 2e       	mov	r14, r25
    d4c0:	95 e0       	ldi	r25, 0x05	; 5
    d4c2:	f9 2e       	mov	r15, r25
{
	byte retries;

	for (retries = 0; retries < HTTP_RETRIES; retries++, delay_secs(HTTP_PAUSE_BETWEEN_RETRIES))
	{
		contentLength = 0;
    d4c4:	10 92 e5 0e 	sts	0x0EE5, r1	; 0x800ee5 <contentLength+0x1>
    d4c8:	10 92 e4 0e 	sts	0x0EE4, r1	; 0x800ee4 <contentLength>

		// first send request to server to get file information
		if (sendHTTP("PUT /status/%l/%d/%d/%s HTTP/1.1\r\nHost: %s\r\nUser-Agent: logger/1.0\r\n\r\n", 30, NULL,
    d4cc:	0e 94 84 73 	call	0xe708	; 0xe708 <getVersion>
    d4d0:	1f 93       	push	r17
    d4d2:	0f 93       	push	r16
    d4d4:	9f 93       	push	r25
    d4d6:	8f 93       	push	r24
    d4d8:	80 91 3d 06 	lds	r24, 0x063D	; 0x80063d <appHeader+0x5>
    d4dc:	8f 93       	push	r24
    d4de:	80 91 3c 06 	lds	r24, 0x063C	; 0x80063c <appHeader+0x4>
    d4e2:	8f 93       	push	r24
    d4e4:	1f 92       	push	r1
    d4e6:	df 93       	push	r29
    d4e8:	80 91 72 05 	lds	r24, 0x0572	; 0x800572 <appEepromData+0x3>
    d4ec:	8f 93       	push	r24
    d4ee:	80 91 71 05 	lds	r24, 0x0571	; 0x800571 <appEepromData+0x2>
    d4f2:	8f 93       	push	r24
    d4f4:	80 91 70 05 	lds	r24, 0x0570	; 0x800570 <appEepromData+0x1>
    d4f8:	8f 93       	push	r24
    d4fa:	80 91 6f 05 	lds	r24, 0x056F	; 0x80056f <appEepromData>
    d4fe:	8f 93       	push	r24
    d500:	1f 92       	push	r1
    d502:	1f 92       	push	r1
    d504:	1f 92       	push	r1
    d506:	df 92       	push	r13
    d508:	ff 92       	push	r15
    d50a:	ef 92       	push	r14
    d50c:	0e 94 bd 78 	call	0xf17a	; 0xf17a <sendHTTP>
    d510:	2d b7       	in	r18, 0x3d	; 61
    d512:	3e b7       	in	r19, 0x3e	; 62
    d514:	2e 5e       	subi	r18, 0xEE	; 238
    d516:	3f 4f       	sbci	r19, 0xFF	; 255
    d518:	0f b6       	in	r0, 0x3f	; 63
    d51a:	f8 94       	cli
    d51c:	3e bf       	out	0x3e, r19	; 62
    d51e:	0f be       	out	0x3f, r0	; 63
    d520:	2d bf       	out	0x3d, r18	; 61
    d522:	87 ff       	sbrs	r24, 7
    d524:	08 c0       	rjmp	.+16     	; 0xd536 <updateFirmwareStatus+0x94>

bool BLSPARE updateFirmwareStatus(byte status)
{
	byte retries;

	for (retries = 0; retries < HTTP_RETRIES; retries++, delay_secs(HTTP_PAUSE_BETWEEN_RETRIES))
    d526:	82 e0       	ldi	r24, 0x02	; 2
    d528:	90 e0       	ldi	r25, 0x00	; 0
    d52a:	0e 94 7b 70 	call	0xe0f6	; 0xe0f6 <delay_secs>
    d52e:	c1 50       	subi	r28, 0x01	; 1
    d530:	49 f6       	brne	.-110    	; 0xd4c4 <updateFirmwareStatus+0x22>
		}

		return true;
	}

	return false;
    d532:	80 e0       	ldi	r24, 0x00	; 0
    d534:	05 c0       	rjmp	.+10     	; 0xd540 <updateFirmwareStatus+0x9e>
		{
			continue;
		}

		// now we can parse response
		if (!isHTTPOK())
    d536:	0e 94 0f 69 	call	0xd21e	; 0xd21e <isHTTPOK>
    d53a:	88 23       	and	r24, r24
    d53c:	a1 f3       	breq	.-24     	; 0xd526 <updateFirmwareStatus+0x84>
		{
			continue;
		}

		return true;
    d53e:	81 e0       	ldi	r24, 0x01	; 1
	}

	return false;
}
    d540:	df 91       	pop	r29
    d542:	cf 91       	pop	r28
    d544:	1f 91       	pop	r17
    d546:	0f 91       	pop	r16
    d548:	ff 90       	pop	r15
    d54a:	ef 90       	pop	r14
    d54c:	df 90       	pop	r13
    d54e:	08 95       	ret
